/* automatically generated by rust-bindgen 0.72.0 */

pub const FT_RENDER_POOL_SIZE: u32 = 16384;
pub const FT_MAX_MODULES: u32 = 32;
pub const FT_INT64_ZERO: u32 = 0;
pub const FT_OUTLINE_NONE: u32 = 0;
pub const FT_OUTLINE_OWNER: u32 = 1;
pub const FT_OUTLINE_EVEN_ODD_FILL: u32 = 2;
pub const FT_OUTLINE_REVERSE_FILL: u32 = 4;
pub const FT_OUTLINE_IGNORE_DROPOUTS: u32 = 8;
pub const FT_OUTLINE_SMART_DROPOUTS: u32 = 16;
pub const FT_OUTLINE_INCLUDE_STUBS: u32 = 32;
pub const FT_OUTLINE_OVERLAP: u32 = 64;
pub const FT_OUTLINE_HIGH_PRECISION: u32 = 256;
pub const FT_OUTLINE_SINGLE_PASS: u32 = 512;
pub const FT_CURVE_TAG_ON: u32 = 1;
pub const FT_CURVE_TAG_CONIC: u32 = 0;
pub const FT_CURVE_TAG_CUBIC: u32 = 2;
pub const FT_CURVE_TAG_HAS_SCANMODE: u32 = 4;
pub const FT_CURVE_TAG_TOUCH_X: u32 = 8;
pub const FT_CURVE_TAG_TOUCH_Y: u32 = 16;
pub const FT_CURVE_TAG_TOUCH_BOTH: u32 = 24;
pub const FT_Curve_Tag_On: u32 = 1;
pub const FT_Curve_Tag_Conic: u32 = 0;
pub const FT_Curve_Tag_Cubic: u32 = 2;
pub const FT_Curve_Tag_Touch_X: u32 = 8;
pub const FT_Curve_Tag_Touch_Y: u32 = 16;
pub const FT_RASTER_FLAG_DEFAULT: u32 = 0;
pub const FT_RASTER_FLAG_AA: u32 = 1;
pub const FT_RASTER_FLAG_DIRECT: u32 = 2;
pub const FT_RASTER_FLAG_CLIP: u32 = 4;
pub const FT_RASTER_FLAG_SDF: u32 = 8;
pub const FT_ERR_BASE: u32 = 0;
pub const FT_FACE_FLAG_SCALABLE: u32 = 1;
pub const FT_FACE_FLAG_FIXED_SIZES: u32 = 2;
pub const FT_FACE_FLAG_FIXED_WIDTH: u32 = 4;
pub const FT_FACE_FLAG_SFNT: u32 = 8;
pub const FT_FACE_FLAG_HORIZONTAL: u32 = 16;
pub const FT_FACE_FLAG_VERTICAL: u32 = 32;
pub const FT_FACE_FLAG_KERNING: u32 = 64;
pub const FT_FACE_FLAG_FAST_GLYPHS: u32 = 128;
pub const FT_FACE_FLAG_MULTIPLE_MASTERS: u32 = 256;
pub const FT_FACE_FLAG_GLYPH_NAMES: u32 = 512;
pub const FT_FACE_FLAG_EXTERNAL_STREAM: u32 = 1024;
pub const FT_FACE_FLAG_HINTER: u32 = 2048;
pub const FT_FACE_FLAG_CID_KEYED: u32 = 4096;
pub const FT_FACE_FLAG_TRICKY: u32 = 8192;
pub const FT_FACE_FLAG_COLOR: u32 = 16384;
pub const FT_FACE_FLAG_VARIATION: u32 = 32768;
pub const FT_FACE_FLAG_SVG: u32 = 65536;
pub const FT_FACE_FLAG_SBIX: u32 = 131072;
pub const FT_FACE_FLAG_SBIX_OVERLAY: u32 = 262144;
pub const FT_STYLE_FLAG_ITALIC: u32 = 1;
pub const FT_STYLE_FLAG_BOLD: u32 = 2;
pub const FT_OPEN_MEMORY: u32 = 1;
pub const FT_OPEN_STREAM: u32 = 2;
pub const FT_OPEN_PATHNAME: u32 = 4;
pub const FT_OPEN_DRIVER: u32 = 8;
pub const FT_OPEN_PARAMS: u32 = 16;
pub const FT_LOAD_DEFAULT: u32 = 0;
pub const FT_LOAD_NO_SCALE: u32 = 1;
pub const FT_LOAD_NO_HINTING: u32 = 2;
pub const FT_LOAD_RENDER: u32 = 4;
pub const FT_LOAD_NO_BITMAP: u32 = 8;
pub const FT_LOAD_VERTICAL_LAYOUT: u32 = 16;
pub const FT_LOAD_FORCE_AUTOHINT: u32 = 32;
pub const FT_LOAD_CROP_BITMAP: u32 = 64;
pub const FT_LOAD_PEDANTIC: u32 = 128;
pub const FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH: u32 = 512;
pub const FT_LOAD_NO_RECURSE: u32 = 1024;
pub const FT_LOAD_IGNORE_TRANSFORM: u32 = 2048;
pub const FT_LOAD_MONOCHROME: u32 = 4096;
pub const FT_LOAD_LINEAR_DESIGN: u32 = 8192;
pub const FT_LOAD_SBITS_ONLY: u32 = 16384;
pub const FT_LOAD_NO_AUTOHINT: u32 = 32768;
pub const FT_LOAD_COLOR: u32 = 1048576;
pub const FT_LOAD_COMPUTE_METRICS: u32 = 2097152;
pub const FT_LOAD_BITMAP_METRICS_ONLY: u32 = 4194304;
pub const FT_LOAD_NO_SVG: u32 = 16777216;
pub const FT_LOAD_ADVANCE_ONLY: u32 = 256;
pub const FT_LOAD_SVG_ONLY: u32 = 8388608;
pub const FT_SUBGLYPH_FLAG_ARGS_ARE_WORDS: u32 = 1;
pub const FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES: u32 = 2;
pub const FT_SUBGLYPH_FLAG_ROUND_XY_TO_GRID: u32 = 4;
pub const FT_SUBGLYPH_FLAG_SCALE: u32 = 8;
pub const FT_SUBGLYPH_FLAG_XY_SCALE: u32 = 64;
pub const FT_SUBGLYPH_FLAG_2X2: u32 = 128;
pub const FT_SUBGLYPH_FLAG_USE_MY_METRICS: u32 = 512;
pub const FT_FSTYPE_INSTALLABLE_EMBEDDING: u32 = 0;
pub const FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING: u32 = 2;
pub const FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING: u32 = 4;
pub const FT_FSTYPE_EDITABLE_EMBEDDING: u32 = 8;
pub const FT_FSTYPE_NO_SUBSETTING: u32 = 256;
pub const FT_FSTYPE_BITMAP_EMBEDDING_ONLY: u32 = 512;
pub const FT_LCD_FILTER_FIVE_TAPS: u32 = 5;
pub const FT_MODULE_FONT_DRIVER: u32 = 1;
pub const FT_MODULE_RENDERER: u32 = 2;
pub const FT_MODULE_HINTER: u32 = 4;
pub const FT_MODULE_STYLER: u32 = 8;
pub const FT_MODULE_DRIVER_SCALABLE: u32 = 256;
pub const FT_MODULE_DRIVER_NO_OUTLINES: u32 = 512;
pub const FT_MODULE_DRIVER_HAS_HINTER: u32 = 1024;
pub const FT_MODULE_DRIVER_HINTS_LIGHTLY: u32 = 2048;
pub const FT_DEBUG_HOOK_TRUETYPE: u32 = 0;
#[doc = " @type:\n   FT_Int16\n\n @description:\n   A typedef for a 16bit signed integer type."]
pub type FT_Int16 = ::std::os::raw::c_short;
#[doc = " @type:\n   FT_UInt16\n\n @description:\n   A typedef for a 16bit unsigned integer type."]
pub type FT_UInt16 = ::std::os::raw::c_ushort;
pub type FT_Int32 = ::std::os::raw::c_int;
pub type FT_UInt32 = ::std::os::raw::c_uint;
pub type FT_Fast = ::std::os::raw::c_int;
pub type FT_UFast = ::std::os::raw::c_uint;
pub type FT_Int64 = ::std::os::raw::c_long;
pub type FT_UInt64 = ::std::os::raw::c_ulong;
#[doc = " @type:\n   FT_Memory\n\n @description:\n   A handle to a given memory manager object, defined with an\n   @FT_MemoryRec structure.\n"]
pub type FT_Memory = *mut FT_MemoryRec_;
#[doc = " @functype:\n   FT_Alloc_Func\n\n @description:\n   A function used to allocate `size` bytes from `memory`.\n\n @input:\n   memory ::\n     A handle to the source memory manager.\n\n   size ::\n     The size in bytes to allocate.\n\n @return:\n   Address of new memory block.  0~in case of failure.\n"]
pub type FT_Alloc_Func = ::std::option::Option<
    unsafe extern "C" fn(
        memory: FT_Memory,
        size: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " @functype:\n   FT_Free_Func\n\n @description:\n   A function used to release a given block of memory.\n\n @input:\n   memory ::\n     A handle to the source memory manager.\n\n   block ::\n     The address of the target memory block.\n"]
pub type FT_Free_Func = ::std::option::Option<
    unsafe extern "C" fn(memory: FT_Memory, block: *mut ::std::os::raw::c_void),
>;
#[doc = " @functype:\n   FT_Realloc_Func\n\n @description:\n   A function used to re-allocate a given block of memory.\n\n @input:\n   memory ::\n     A handle to the source memory manager.\n\n   cur_size ::\n     The block's current size in bytes.\n\n   new_size ::\n     The block's requested new size.\n\n   block ::\n     The block's current address.\n\n @return:\n   New block address.  0~in case of memory shortage.\n\n @note:\n   In case of error, the old block must still be available.\n"]
pub type FT_Realloc_Func = ::std::option::Option<
    unsafe extern "C" fn(
        memory: FT_Memory,
        cur_size: ::std::os::raw::c_long,
        new_size: ::std::os::raw::c_long,
        block: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " @struct:\n   FT_MemoryRec\n\n @description:\n   A structure used to describe a given memory manager to FreeType~2.\n\n @fields:\n   user ::\n     A generic typeless pointer for user data.\n\n   alloc ::\n     A pointer type to an allocation function.\n\n   free ::\n     A pointer type to an memory freeing function.\n\n   realloc ::\n     A pointer type to a reallocation function.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_MemoryRec_ {
    pub user: *mut ::std::os::raw::c_void,
    pub alloc: FT_Alloc_Func,
    pub free: FT_Free_Func,
    pub realloc: FT_Realloc_Func,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_MemoryRec_"][::std::mem::size_of::<FT_MemoryRec_>() - 32usize];
    ["Alignment of FT_MemoryRec_"][::std::mem::align_of::<FT_MemoryRec_>() - 8usize];
    ["Offset of field: FT_MemoryRec_::user"][::std::mem::offset_of!(FT_MemoryRec_, user) - 0usize];
    ["Offset of field: FT_MemoryRec_::alloc"]
        [::std::mem::offset_of!(FT_MemoryRec_, alloc) - 8usize];
    ["Offset of field: FT_MemoryRec_::free"][::std::mem::offset_of!(FT_MemoryRec_, free) - 16usize];
    ["Offset of field: FT_MemoryRec_::realloc"]
        [::std::mem::offset_of!(FT_MemoryRec_, realloc) - 24usize];
};
#[doc = " @type:\n   FT_Stream\n\n @description:\n   A handle to an input stream.\n\n @also:\n   See @FT_StreamRec for the publicly accessible fields of a given stream\n   object.\n"]
pub type FT_Stream = *mut FT_StreamRec_;
#[doc = " @struct:\n   FT_StreamDesc\n\n @description:\n   A union type used to store either a long or a pointer.  This is used\n   to store a file descriptor or a `FILE*` in an input stream.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union FT_StreamDesc_ {
    pub value: ::std::os::raw::c_long,
    pub pointer: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_StreamDesc_"][::std::mem::size_of::<FT_StreamDesc_>() - 8usize];
    ["Alignment of FT_StreamDesc_"][::std::mem::align_of::<FT_StreamDesc_>() - 8usize];
    ["Offset of field: FT_StreamDesc_::value"]
        [::std::mem::offset_of!(FT_StreamDesc_, value) - 0usize];
    ["Offset of field: FT_StreamDesc_::pointer"]
        [::std::mem::offset_of!(FT_StreamDesc_, pointer) - 0usize];
};
#[doc = " @struct:\n   FT_StreamDesc\n\n @description:\n   A union type used to store either a long or a pointer.  This is used\n   to store a file descriptor or a `FILE*` in an input stream.\n"]
pub type FT_StreamDesc = FT_StreamDesc_;
#[doc = " @functype:\n   FT_Stream_IoFunc\n\n @description:\n   A function used to seek and read data from a given input stream.\n\n @input:\n   stream ::\n     A handle to the source stream.\n\n   offset ::\n     The offset from the start of the stream to seek to.\n\n   buffer ::\n     The address of the read buffer.\n\n   count ::\n     The number of bytes to read from the stream.\n\n @return:\n   If count >~0, return the number of bytes effectively read by the\n   stream (after seeking to `offset`).  If count ==~0, return the status\n   of the seek operation (non-zero indicates an error).\n"]
pub type FT_Stream_IoFunc = ::std::option::Option<
    unsafe extern "C" fn(
        stream: FT_Stream,
        offset: ::std::os::raw::c_ulong,
        buffer: *mut ::std::os::raw::c_uchar,
        count: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong,
>;
#[doc = " @functype:\n   FT_Stream_CloseFunc\n\n @description:\n   A function used to close a given input stream.\n\n @input:\n  stream ::\n    A handle to the target stream.\n"]
pub type FT_Stream_CloseFunc = ::std::option::Option<unsafe extern "C" fn(stream: FT_Stream)>;
#[doc = " @struct:\n   FT_StreamRec\n\n @description:\n   A structure used to describe an input stream.\n\n @input:\n   base ::\n     For memory-based streams, this is the address of the first stream\n     byte in memory.  This field should always be set to `NULL` for\n     disk-based streams.\n\n   size ::\n     The stream size in bytes.\n\n     In case of compressed streams where the size is unknown before\n     actually doing the decompression, the value is set to 0x7FFFFFFF.\n     (Note that this size value can occur for normal streams also; it is\n     thus just a hint.)\n\n   pos ::\n     The current position within the stream.\n\n   descriptor ::\n     This field is a union that can hold an integer or a pointer.  It is\n     used by stream implementations to store file descriptors or `FILE*`\n     pointers.\n\n   pathname ::\n     This field is completely ignored by FreeType.  However, it is often\n     useful during debugging to use it to store the stream's filename\n     (where available).\n\n   read ::\n     The stream's input function.\n\n   close ::\n     The stream's close function.\n\n   memory ::\n     The memory manager to use to preload frames.  This is set internally\n     by FreeType and shouldn't be touched by stream implementations.\n\n   cursor ::\n     This field is set and used internally by FreeType when parsing\n     frames.  In particular, the `FT_GET_XXX` macros use this instead of\n     the `pos` field.\n\n   limit ::\n     This field is set and used internally by FreeType when parsing\n     frames.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FT_StreamRec_ {
    pub base: *mut ::std::os::raw::c_uchar,
    pub size: ::std::os::raw::c_ulong,
    pub pos: ::std::os::raw::c_ulong,
    pub descriptor: FT_StreamDesc,
    pub pathname: FT_StreamDesc,
    pub read: FT_Stream_IoFunc,
    pub close: FT_Stream_CloseFunc,
    pub memory: FT_Memory,
    pub cursor: *mut ::std::os::raw::c_uchar,
    pub limit: *mut ::std::os::raw::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_StreamRec_"][::std::mem::size_of::<FT_StreamRec_>() - 80usize];
    ["Alignment of FT_StreamRec_"][::std::mem::align_of::<FT_StreamRec_>() - 8usize];
    ["Offset of field: FT_StreamRec_::base"][::std::mem::offset_of!(FT_StreamRec_, base) - 0usize];
    ["Offset of field: FT_StreamRec_::size"][::std::mem::offset_of!(FT_StreamRec_, size) - 8usize];
    ["Offset of field: FT_StreamRec_::pos"][::std::mem::offset_of!(FT_StreamRec_, pos) - 16usize];
    ["Offset of field: FT_StreamRec_::descriptor"]
        [::std::mem::offset_of!(FT_StreamRec_, descriptor) - 24usize];
    ["Offset of field: FT_StreamRec_::pathname"]
        [::std::mem::offset_of!(FT_StreamRec_, pathname) - 32usize];
    ["Offset of field: FT_StreamRec_::read"][::std::mem::offset_of!(FT_StreamRec_, read) - 40usize];
    ["Offset of field: FT_StreamRec_::close"]
        [::std::mem::offset_of!(FT_StreamRec_, close) - 48usize];
    ["Offset of field: FT_StreamRec_::memory"]
        [::std::mem::offset_of!(FT_StreamRec_, memory) - 56usize];
    ["Offset of field: FT_StreamRec_::cursor"]
        [::std::mem::offset_of!(FT_StreamRec_, cursor) - 64usize];
    ["Offset of field: FT_StreamRec_::limit"]
        [::std::mem::offset_of!(FT_StreamRec_, limit) - 72usize];
};
#[doc = " @struct:\n   FT_StreamRec\n\n @description:\n   A structure used to describe an input stream.\n\n @input:\n   base ::\n     For memory-based streams, this is the address of the first stream\n     byte in memory.  This field should always be set to `NULL` for\n     disk-based streams.\n\n   size ::\n     The stream size in bytes.\n\n     In case of compressed streams where the size is unknown before\n     actually doing the decompression, the value is set to 0x7FFFFFFF.\n     (Note that this size value can occur for normal streams also; it is\n     thus just a hint.)\n\n   pos ::\n     The current position within the stream.\n\n   descriptor ::\n     This field is a union that can hold an integer or a pointer.  It is\n     used by stream implementations to store file descriptors or `FILE*`\n     pointers.\n\n   pathname ::\n     This field is completely ignored by FreeType.  However, it is often\n     useful during debugging to use it to store the stream's filename\n     (where available).\n\n   read ::\n     The stream's input function.\n\n   close ::\n     The stream's close function.\n\n   memory ::\n     The memory manager to use to preload frames.  This is set internally\n     by FreeType and shouldn't be touched by stream implementations.\n\n   cursor ::\n     This field is set and used internally by FreeType when parsing\n     frames.  In particular, the `FT_GET_XXX` macros use this instead of\n     the `pos` field.\n\n   limit ::\n     This field is set and used internally by FreeType when parsing\n     frames.\n"]
pub type FT_StreamRec = FT_StreamRec_;
#[doc = " @type:\n   FT_Pos\n\n @description:\n   The type FT_Pos is used to store vectorial coordinates.  Depending on\n   the context, these can represent distances in integer font units, or\n   16.16, or 26.6 fixed-point pixel coordinates."]
pub type FT_Pos = ::std::os::raw::c_long;
#[doc = " @struct:\n   FT_Vector\n\n @description:\n   A simple structure used to store a 2D vector; coordinates are of the\n   FT_Pos type.\n\n @fields:\n   x ::\n     The horizontal coordinate.\n   y ::\n     The vertical coordinate."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Vector_ {
    pub x: FT_Pos,
    pub y: FT_Pos,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_Vector_"][::std::mem::size_of::<FT_Vector_>() - 16usize];
    ["Alignment of FT_Vector_"][::std::mem::align_of::<FT_Vector_>() - 8usize];
    ["Offset of field: FT_Vector_::x"][::std::mem::offset_of!(FT_Vector_, x) - 0usize];
    ["Offset of field: FT_Vector_::y"][::std::mem::offset_of!(FT_Vector_, y) - 8usize];
};
#[doc = " @struct:\n   FT_Vector\n\n @description:\n   A simple structure used to store a 2D vector; coordinates are of the\n   FT_Pos type.\n\n @fields:\n   x ::\n     The horizontal coordinate.\n   y ::\n     The vertical coordinate."]
pub type FT_Vector = FT_Vector_;
#[doc = " @struct:\n   FT_BBox\n\n @description:\n   A structure used to hold an outline's bounding box, i.e., the\n   coordinates of its extrema in the horizontal and vertical directions.\n\n @fields:\n   xMin ::\n     The horizontal minimum (left-most).\n\n   yMin ::\n     The vertical minimum (bottom-most).\n\n   xMax ::\n     The horizontal maximum (right-most).\n\n   yMax ::\n     The vertical maximum (top-most).\n\n @note:\n   The bounding box is specified with the coordinates of the lower left\n   and the upper right corner.  In PostScript, those values are often\n   called (llx,lly) and (urx,ury), respectively.\n\n   If `yMin` is negative, this value gives the glyph's descender.\n   Otherwise, the glyph doesn't descend below the baseline.  Similarly,\n   if `ymax` is positive, this value gives the glyph's ascender.\n\n   `xMin` gives the horizontal distance from the glyph's origin to the\n   left edge of the glyph's bounding box.  If `xMin` is negative, the\n   glyph extends to the left of the origin."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_BBox_ {
    pub xMin: FT_Pos,
    pub yMin: FT_Pos,
    pub xMax: FT_Pos,
    pub yMax: FT_Pos,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_BBox_"][::std::mem::size_of::<FT_BBox_>() - 32usize];
    ["Alignment of FT_BBox_"][::std::mem::align_of::<FT_BBox_>() - 8usize];
    ["Offset of field: FT_BBox_::xMin"][::std::mem::offset_of!(FT_BBox_, xMin) - 0usize];
    ["Offset of field: FT_BBox_::yMin"][::std::mem::offset_of!(FT_BBox_, yMin) - 8usize];
    ["Offset of field: FT_BBox_::xMax"][::std::mem::offset_of!(FT_BBox_, xMax) - 16usize];
    ["Offset of field: FT_BBox_::yMax"][::std::mem::offset_of!(FT_BBox_, yMax) - 24usize];
};
#[doc = " @struct:\n   FT_BBox\n\n @description:\n   A structure used to hold an outline's bounding box, i.e., the\n   coordinates of its extrema in the horizontal and vertical directions.\n\n @fields:\n   xMin ::\n     The horizontal minimum (left-most).\n\n   yMin ::\n     The vertical minimum (bottom-most).\n\n   xMax ::\n     The horizontal maximum (right-most).\n\n   yMax ::\n     The vertical maximum (top-most).\n\n @note:\n   The bounding box is specified with the coordinates of the lower left\n   and the upper right corner.  In PostScript, those values are often\n   called (llx,lly) and (urx,ury), respectively.\n\n   If `yMin` is negative, this value gives the glyph's descender.\n   Otherwise, the glyph doesn't descend below the baseline.  Similarly,\n   if `ymax` is positive, this value gives the glyph's ascender.\n\n   `xMin` gives the horizontal distance from the glyph's origin to the\n   left edge of the glyph's bounding box.  If `xMin` is negative, the\n   glyph extends to the left of the origin."]
pub type FT_BBox = FT_BBox_;
pub const FT_Pixel_Mode__FT_PIXEL_MODE_NONE: FT_Pixel_Mode_ = 0;
pub const FT_Pixel_Mode__FT_PIXEL_MODE_MONO: FT_Pixel_Mode_ = 1;
pub const FT_Pixel_Mode__FT_PIXEL_MODE_GRAY: FT_Pixel_Mode_ = 2;
pub const FT_Pixel_Mode__FT_PIXEL_MODE_GRAY2: FT_Pixel_Mode_ = 3;
pub const FT_Pixel_Mode__FT_PIXEL_MODE_GRAY4: FT_Pixel_Mode_ = 4;
pub const FT_Pixel_Mode__FT_PIXEL_MODE_LCD: FT_Pixel_Mode_ = 5;
pub const FT_Pixel_Mode__FT_PIXEL_MODE_LCD_V: FT_Pixel_Mode_ = 6;
pub const FT_Pixel_Mode__FT_PIXEL_MODE_BGRA: FT_Pixel_Mode_ = 7;
pub const FT_Pixel_Mode__FT_PIXEL_MODE_MAX: FT_Pixel_Mode_ = 8;
#[doc = " @enum:\n   FT_Pixel_Mode\n\n @description:\n   An enumeration type used to describe the format of pixels in a given\n   bitmap.  Note that additional formats may be added in the future.\n\n @values:\n   FT_PIXEL_MODE_NONE ::\n     Value~0 is reserved.\n\n   FT_PIXEL_MODE_MONO ::\n     A monochrome bitmap, using 1~bit per pixel.  Note that pixels are\n     stored in most-significant order (MSB), which means that the\n     left-most pixel in a byte has value 128.\n\n   FT_PIXEL_MODE_GRAY ::\n     An 8-bit bitmap, generally used to represent anti-aliased glyph\n     images.  Each pixel is stored in one byte.  Note that the number of\n     'gray' levels is stored in the `num_grays` field of the @FT_Bitmap\n     structure (it generally is 256).\n\n   FT_PIXEL_MODE_GRAY2 ::\n     A 2-bit per pixel bitmap, used to represent embedded anti-aliased\n     bitmaps in font files according to the OpenType specification.  We\n     haven't found a single font using this format, however.\n\n   FT_PIXEL_MODE_GRAY4 ::\n     A 4-bit per pixel bitmap, representing embedded anti-aliased bitmaps\n     in font files according to the OpenType specification.  We haven't\n     found a single font using this format, however.\n\n   FT_PIXEL_MODE_LCD ::\n     An 8-bit bitmap, representing RGB or BGR decimated glyph images used\n     for display on LCD displays; the bitmap is three times wider than\n     the original glyph image.  See also @FT_RENDER_MODE_LCD.\n\n   FT_PIXEL_MODE_LCD_V ::\n     An 8-bit bitmap, representing RGB or BGR decimated glyph images used\n     for display on rotated LCD displays; the bitmap is three times\n     taller than the original glyph image.  See also\n     @FT_RENDER_MODE_LCD_V.\n\n   FT_PIXEL_MODE_BGRA ::\n     [Since 2.5] An image with four 8-bit channels per pixel,\n     representing a color image (such as emoticons) with alpha channel.\n     For each pixel, the format is BGRA, which means, the blue channel\n     comes first in memory.  The color channels are pre-multiplied and in\n     the sRGB colorspace.  For example, full red at half-translucent\n     opacity will be represented as '00,00,80,80', not '00,00,FF,80'.\n     See also @FT_LOAD_COLOR."]
pub type FT_Pixel_Mode_ = ::std::os::raw::c_uint;
#[doc = " @enum:\n   FT_Pixel_Mode\n\n @description:\n   An enumeration type used to describe the format of pixels in a given\n   bitmap.  Note that additional formats may be added in the future.\n\n @values:\n   FT_PIXEL_MODE_NONE ::\n     Value~0 is reserved.\n\n   FT_PIXEL_MODE_MONO ::\n     A monochrome bitmap, using 1~bit per pixel.  Note that pixels are\n     stored in most-significant order (MSB), which means that the\n     left-most pixel in a byte has value 128.\n\n   FT_PIXEL_MODE_GRAY ::\n     An 8-bit bitmap, generally used to represent anti-aliased glyph\n     images.  Each pixel is stored in one byte.  Note that the number of\n     'gray' levels is stored in the `num_grays` field of the @FT_Bitmap\n     structure (it generally is 256).\n\n   FT_PIXEL_MODE_GRAY2 ::\n     A 2-bit per pixel bitmap, used to represent embedded anti-aliased\n     bitmaps in font files according to the OpenType specification.  We\n     haven't found a single font using this format, however.\n\n   FT_PIXEL_MODE_GRAY4 ::\n     A 4-bit per pixel bitmap, representing embedded anti-aliased bitmaps\n     in font files according to the OpenType specification.  We haven't\n     found a single font using this format, however.\n\n   FT_PIXEL_MODE_LCD ::\n     An 8-bit bitmap, representing RGB or BGR decimated glyph images used\n     for display on LCD displays; the bitmap is three times wider than\n     the original glyph image.  See also @FT_RENDER_MODE_LCD.\n\n   FT_PIXEL_MODE_LCD_V ::\n     An 8-bit bitmap, representing RGB or BGR decimated glyph images used\n     for display on rotated LCD displays; the bitmap is three times\n     taller than the original glyph image.  See also\n     @FT_RENDER_MODE_LCD_V.\n\n   FT_PIXEL_MODE_BGRA ::\n     [Since 2.5] An image with four 8-bit channels per pixel,\n     representing a color image (such as emoticons) with alpha channel.\n     For each pixel, the format is BGRA, which means, the blue channel\n     comes first in memory.  The color channels are pre-multiplied and in\n     the sRGB colorspace.  For example, full red at half-translucent\n     opacity will be represented as '00,00,80,80', not '00,00,FF,80'.\n     See also @FT_LOAD_COLOR."]
pub use self::FT_Pixel_Mode_ as FT_Pixel_Mode;
#[doc = " @struct:\n   FT_Bitmap\n\n @description:\n   A structure used to describe a bitmap or pixmap to the raster.  Note\n   that we now manage pixmaps of various depths through the `pixel_mode`\n   field.\n\n @fields:\n   rows ::\n     The number of bitmap rows.\n\n   width ::\n     The number of pixels in bitmap row.\n\n   pitch ::\n     The pitch's absolute value is the number of bytes taken by one\n     bitmap row, including padding.  However, the pitch is positive when\n     the bitmap has a 'down' flow, and negative when it has an 'up' flow.\n     In all cases, the pitch is an offset to add to a bitmap pointer in\n     order to go down one row.\n\n     Note that 'padding' means the alignment of a bitmap to a byte\n     border, and FreeType functions normally align to the smallest\n     possible integer value.\n\n     For the B/W rasterizer, `pitch` is always an even number.\n\n     To change the pitch of a bitmap (say, to make it a multiple of 4),\n     use @FT_Bitmap_Convert.  Alternatively, you might use callback\n     functions to directly render to the application's surface; see the\n     file `example2.cpp` in the tutorial for a demonstration.\n\n   buffer ::\n     A typeless pointer to the bitmap buffer.  This value should be\n     aligned on 32-bit boundaries in most cases.\n\n   num_grays ::\n     This field is only used with @FT_PIXEL_MODE_GRAY; it gives the\n     number of gray levels used in the bitmap.\n\n   pixel_mode ::\n     The pixel mode, i.e., how pixel bits are stored.  See @FT_Pixel_Mode\n     for possible values.\n\n   palette_mode ::\n     This field is intended for paletted pixel modes; it indicates how\n     the palette is stored.  Not used currently.\n\n   palette ::\n     A typeless pointer to the bitmap palette; this field is intended for\n     paletted pixel modes.  Not used currently.\n\n @note:\n   `width` and `rows` refer to the *physical* size of the bitmap, not the\n   *logical* one.  For example, if @FT_Pixel_Mode is set to\n   `FT_PIXEL_MODE_LCD`, the logical width is a just a third of the\n   physical one.\n\n   An empty bitmap with a NULL `buffer` is valid, with `rows` and/or\n   `pitch` also set to 0.  Such bitmaps might be produced while rendering\n   empty or degenerate outlines."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Bitmap_ {
    pub rows: ::std::os::raw::c_uint,
    pub width: ::std::os::raw::c_uint,
    pub pitch: ::std::os::raw::c_int,
    pub buffer: *mut ::std::os::raw::c_uchar,
    pub num_grays: ::std::os::raw::c_ushort,
    pub pixel_mode: ::std::os::raw::c_uchar,
    pub palette_mode: ::std::os::raw::c_uchar,
    pub palette: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_Bitmap_"][::std::mem::size_of::<FT_Bitmap_>() - 40usize];
    ["Alignment of FT_Bitmap_"][::std::mem::align_of::<FT_Bitmap_>() - 8usize];
    ["Offset of field: FT_Bitmap_::rows"][::std::mem::offset_of!(FT_Bitmap_, rows) - 0usize];
    ["Offset of field: FT_Bitmap_::width"][::std::mem::offset_of!(FT_Bitmap_, width) - 4usize];
    ["Offset of field: FT_Bitmap_::pitch"][::std::mem::offset_of!(FT_Bitmap_, pitch) - 8usize];
    ["Offset of field: FT_Bitmap_::buffer"][::std::mem::offset_of!(FT_Bitmap_, buffer) - 16usize];
    ["Offset of field: FT_Bitmap_::num_grays"]
        [::std::mem::offset_of!(FT_Bitmap_, num_grays) - 24usize];
    ["Offset of field: FT_Bitmap_::pixel_mode"]
        [::std::mem::offset_of!(FT_Bitmap_, pixel_mode) - 26usize];
    ["Offset of field: FT_Bitmap_::palette_mode"]
        [::std::mem::offset_of!(FT_Bitmap_, palette_mode) - 27usize];
    ["Offset of field: FT_Bitmap_::palette"][::std::mem::offset_of!(FT_Bitmap_, palette) - 32usize];
};
#[doc = " @struct:\n   FT_Bitmap\n\n @description:\n   A structure used to describe a bitmap or pixmap to the raster.  Note\n   that we now manage pixmaps of various depths through the `pixel_mode`\n   field.\n\n @fields:\n   rows ::\n     The number of bitmap rows.\n\n   width ::\n     The number of pixels in bitmap row.\n\n   pitch ::\n     The pitch's absolute value is the number of bytes taken by one\n     bitmap row, including padding.  However, the pitch is positive when\n     the bitmap has a 'down' flow, and negative when it has an 'up' flow.\n     In all cases, the pitch is an offset to add to a bitmap pointer in\n     order to go down one row.\n\n     Note that 'padding' means the alignment of a bitmap to a byte\n     border, and FreeType functions normally align to the smallest\n     possible integer value.\n\n     For the B/W rasterizer, `pitch` is always an even number.\n\n     To change the pitch of a bitmap (say, to make it a multiple of 4),\n     use @FT_Bitmap_Convert.  Alternatively, you might use callback\n     functions to directly render to the application's surface; see the\n     file `example2.cpp` in the tutorial for a demonstration.\n\n   buffer ::\n     A typeless pointer to the bitmap buffer.  This value should be\n     aligned on 32-bit boundaries in most cases.\n\n   num_grays ::\n     This field is only used with @FT_PIXEL_MODE_GRAY; it gives the\n     number of gray levels used in the bitmap.\n\n   pixel_mode ::\n     The pixel mode, i.e., how pixel bits are stored.  See @FT_Pixel_Mode\n     for possible values.\n\n   palette_mode ::\n     This field is intended for paletted pixel modes; it indicates how\n     the palette is stored.  Not used currently.\n\n   palette ::\n     A typeless pointer to the bitmap palette; this field is intended for\n     paletted pixel modes.  Not used currently.\n\n @note:\n   `width` and `rows` refer to the *physical* size of the bitmap, not the\n   *logical* one.  For example, if @FT_Pixel_Mode is set to\n   `FT_PIXEL_MODE_LCD`, the logical width is a just a third of the\n   physical one.\n\n   An empty bitmap with a NULL `buffer` is valid, with `rows` and/or\n   `pitch` also set to 0.  Such bitmaps might be produced while rendering\n   empty or degenerate outlines."]
pub type FT_Bitmap = FT_Bitmap_;
#[doc = " @struct:\n   FT_Outline\n\n @description:\n   This structure is used to describe an outline to the scan-line\n   converter.\n\n @fields:\n   n_contours ::\n     The number of contours in the outline.\n\n   n_points ::\n     The number of points in the outline.\n\n   points ::\n     A pointer to an array of `n_points` @FT_Vector elements, giving the\n     outline's point coordinates.\n\n   tags ::\n     A pointer to an array of `n_points` chars, giving each outline\n     point's type.\n\n     If bit~0 is unset, the point is 'off' the curve, i.e., a Bezier\n     control point, while it is 'on' if set.\n\n     Bit~1 is meaningful for 'off' points only.  If set, it indicates a\n     third-order Bezier arc control point; and a second-order control\n     point if unset.\n\n     If bit~2 is set, bits 5-7 contain the drop-out mode (as defined in\n     the OpenType specification; the value is the same as the argument to\n     the 'SCANTYPE' instruction).\n\n     Bits 3 and~4 are reserved for internal purposes.\n\n   contours ::\n     An array of `n_contours` shorts, giving the end point of each\n     contour within the outline.  For example, the first contour is\n     defined by the points '0' to `contours[0]`, the second one is\n     defined by the points `contours[0]+1` to `contours[1]`, etc.\n\n   flags ::\n     A set of bit flags used to characterize the outline and give hints\n     to the scan-converter and hinter on how to convert/grid-fit it.  See\n     @FT_OUTLINE_XXX.\n\n @note:\n   The B/W rasterizer only checks bit~2 in the `tags` array for the first\n   point of each contour.  The drop-out mode as given with\n   @FT_OUTLINE_IGNORE_DROPOUTS, @FT_OUTLINE_SMART_DROPOUTS, and\n   @FT_OUTLINE_INCLUDE_STUBS in `flags` is then overridden."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Outline_ {
    pub n_contours: ::std::os::raw::c_ushort,
    pub n_points: ::std::os::raw::c_ushort,
    pub points: *mut FT_Vector,
    pub tags: *mut ::std::os::raw::c_uchar,
    pub contours: *mut ::std::os::raw::c_ushort,
    pub flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_Outline_"][::std::mem::size_of::<FT_Outline_>() - 40usize];
    ["Alignment of FT_Outline_"][::std::mem::align_of::<FT_Outline_>() - 8usize];
    ["Offset of field: FT_Outline_::n_contours"]
        [::std::mem::offset_of!(FT_Outline_, n_contours) - 0usize];
    ["Offset of field: FT_Outline_::n_points"]
        [::std::mem::offset_of!(FT_Outline_, n_points) - 2usize];
    ["Offset of field: FT_Outline_::points"][::std::mem::offset_of!(FT_Outline_, points) - 8usize];
    ["Offset of field: FT_Outline_::tags"][::std::mem::offset_of!(FT_Outline_, tags) - 16usize];
    ["Offset of field: FT_Outline_::contours"]
        [::std::mem::offset_of!(FT_Outline_, contours) - 24usize];
    ["Offset of field: FT_Outline_::flags"][::std::mem::offset_of!(FT_Outline_, flags) - 32usize];
};
#[doc = " @struct:\n   FT_Outline\n\n @description:\n   This structure is used to describe an outline to the scan-line\n   converter.\n\n @fields:\n   n_contours ::\n     The number of contours in the outline.\n\n   n_points ::\n     The number of points in the outline.\n\n   points ::\n     A pointer to an array of `n_points` @FT_Vector elements, giving the\n     outline's point coordinates.\n\n   tags ::\n     A pointer to an array of `n_points` chars, giving each outline\n     point's type.\n\n     If bit~0 is unset, the point is 'off' the curve, i.e., a Bezier\n     control point, while it is 'on' if set.\n\n     Bit~1 is meaningful for 'off' points only.  If set, it indicates a\n     third-order Bezier arc control point; and a second-order control\n     point if unset.\n\n     If bit~2 is set, bits 5-7 contain the drop-out mode (as defined in\n     the OpenType specification; the value is the same as the argument to\n     the 'SCANTYPE' instruction).\n\n     Bits 3 and~4 are reserved for internal purposes.\n\n   contours ::\n     An array of `n_contours` shorts, giving the end point of each\n     contour within the outline.  For example, the first contour is\n     defined by the points '0' to `contours[0]`, the second one is\n     defined by the points `contours[0]+1` to `contours[1]`, etc.\n\n   flags ::\n     A set of bit flags used to characterize the outline and give hints\n     to the scan-converter and hinter on how to convert/grid-fit it.  See\n     @FT_OUTLINE_XXX.\n\n @note:\n   The B/W rasterizer only checks bit~2 in the `tags` array for the first\n   point of each contour.  The drop-out mode as given with\n   @FT_OUTLINE_IGNORE_DROPOUTS, @FT_OUTLINE_SMART_DROPOUTS, and\n   @FT_OUTLINE_INCLUDE_STUBS in `flags` is then overridden."]
pub type FT_Outline = FT_Outline_;
#[doc = " @functype:\n   FT_Outline_MoveToFunc\n\n @description:\n   A function pointer type used to describe the signature of a 'move to'\n   function during outline walking/decomposition.\n\n   A 'move to' is emitted to start a new contour in an outline.\n\n @input:\n   to ::\n     A pointer to the target point of the 'move to'.\n\n   user ::\n     A typeless pointer, which is passed from the caller of the\n     decomposition function.\n\n @return:\n   Error code.  0~means success."]
pub type FT_Outline_MoveToFunc = ::std::option::Option<
    unsafe extern "C" fn(
        to: *const FT_Vector,
        user: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functype:\n   FT_Outline_LineToFunc\n\n @description:\n   A function pointer type used to describe the signature of a 'line to'\n   function during outline walking/decomposition.\n\n   A 'line to' is emitted to indicate a segment in the outline.\n\n @input:\n   to ::\n     A pointer to the target point of the 'line to'.\n\n   user ::\n     A typeless pointer, which is passed from the caller of the\n     decomposition function.\n\n @return:\n   Error code.  0~means success."]
pub type FT_Outline_LineToFunc = ::std::option::Option<
    unsafe extern "C" fn(
        to: *const FT_Vector,
        user: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functype:\n   FT_Outline_ConicToFunc\n\n @description:\n   A function pointer type used to describe the signature of a 'conic to'\n   function during outline walking or decomposition.\n\n   A 'conic to' is emitted to indicate a second-order Bezier arc in the\n   outline.\n\n @input:\n   control ::\n     An intermediate control point between the last position and the new\n     target in `to`.\n\n   to ::\n     A pointer to the target end point of the conic arc.\n\n   user ::\n     A typeless pointer, which is passed from the caller of the\n     decomposition function.\n\n @return:\n   Error code.  0~means success."]
pub type FT_Outline_ConicToFunc = ::std::option::Option<
    unsafe extern "C" fn(
        control: *const FT_Vector,
        to: *const FT_Vector,
        user: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functype:\n   FT_Outline_CubicToFunc\n\n @description:\n   A function pointer type used to describe the signature of a 'cubic to'\n   function during outline walking or decomposition.\n\n   A 'cubic to' is emitted to indicate a third-order Bezier arc.\n\n @input:\n   control1 ::\n     A pointer to the first Bezier control point.\n\n   control2 ::\n     A pointer to the second Bezier control point.\n\n   to ::\n     A pointer to the target end point.\n\n   user ::\n     A typeless pointer, which is passed from the caller of the\n     decomposition function.\n\n @return:\n   Error code.  0~means success."]
pub type FT_Outline_CubicToFunc = ::std::option::Option<
    unsafe extern "C" fn(
        control1: *const FT_Vector,
        control2: *const FT_Vector,
        to: *const FT_Vector,
        user: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @struct:\n   FT_Outline_Funcs\n\n @description:\n   A structure to hold various function pointers used during outline\n   decomposition in order to emit segments, conic, and cubic Beziers.\n\n @fields:\n   move_to ::\n     The 'move to' emitter.\n\n   line_to ::\n     The segment emitter.\n\n   conic_to ::\n     The second-order Bezier arc emitter.\n\n   cubic_to ::\n     The third-order Bezier arc emitter.\n\n   shift ::\n     The shift that is applied to coordinates before they are sent to the\n     emitter.\n\n   delta ::\n     The delta that is applied to coordinates before they are sent to the\n     emitter, but after the shift.\n\n @note:\n   The point coordinates sent to the emitters are the transformed version\n   of the original coordinates (this is important for high accuracy\n   during scan-conversion).  The transformation is simple:\n\n   ```\n     x' = (x << shift) - delta\n     y' = (y << shift) - delta\n   ```\n\n   Set the values of `shift` and `delta` to~0 to get the original point\n   coordinates."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Outline_Funcs_ {
    pub move_to: FT_Outline_MoveToFunc,
    pub line_to: FT_Outline_LineToFunc,
    pub conic_to: FT_Outline_ConicToFunc,
    pub cubic_to: FT_Outline_CubicToFunc,
    pub shift: ::std::os::raw::c_int,
    pub delta: FT_Pos,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_Outline_Funcs_"][::std::mem::size_of::<FT_Outline_Funcs_>() - 48usize];
    ["Alignment of FT_Outline_Funcs_"][::std::mem::align_of::<FT_Outline_Funcs_>() - 8usize];
    ["Offset of field: FT_Outline_Funcs_::move_to"]
        [::std::mem::offset_of!(FT_Outline_Funcs_, move_to) - 0usize];
    ["Offset of field: FT_Outline_Funcs_::line_to"]
        [::std::mem::offset_of!(FT_Outline_Funcs_, line_to) - 8usize];
    ["Offset of field: FT_Outline_Funcs_::conic_to"]
        [::std::mem::offset_of!(FT_Outline_Funcs_, conic_to) - 16usize];
    ["Offset of field: FT_Outline_Funcs_::cubic_to"]
        [::std::mem::offset_of!(FT_Outline_Funcs_, cubic_to) - 24usize];
    ["Offset of field: FT_Outline_Funcs_::shift"]
        [::std::mem::offset_of!(FT_Outline_Funcs_, shift) - 32usize];
    ["Offset of field: FT_Outline_Funcs_::delta"]
        [::std::mem::offset_of!(FT_Outline_Funcs_, delta) - 40usize];
};
#[doc = " @struct:\n   FT_Outline_Funcs\n\n @description:\n   A structure to hold various function pointers used during outline\n   decomposition in order to emit segments, conic, and cubic Beziers.\n\n @fields:\n   move_to ::\n     The 'move to' emitter.\n\n   line_to ::\n     The segment emitter.\n\n   conic_to ::\n     The second-order Bezier arc emitter.\n\n   cubic_to ::\n     The third-order Bezier arc emitter.\n\n   shift ::\n     The shift that is applied to coordinates before they are sent to the\n     emitter.\n\n   delta ::\n     The delta that is applied to coordinates before they are sent to the\n     emitter, but after the shift.\n\n @note:\n   The point coordinates sent to the emitters are the transformed version\n   of the original coordinates (this is important for high accuracy\n   during scan-conversion).  The transformation is simple:\n\n   ```\n     x' = (x << shift) - delta\n     y' = (y << shift) - delta\n   ```\n\n   Set the values of `shift` and `delta` to~0 to get the original point\n   coordinates."]
pub type FT_Outline_Funcs = FT_Outline_Funcs_;
pub const FT_Glyph_Format__FT_GLYPH_FORMAT_NONE: FT_Glyph_Format_ = 0;
pub const FT_Glyph_Format__FT_GLYPH_FORMAT_COMPOSITE: FT_Glyph_Format_ = 1668246896;
pub const FT_Glyph_Format__FT_GLYPH_FORMAT_BITMAP: FT_Glyph_Format_ = 1651078259;
pub const FT_Glyph_Format__FT_GLYPH_FORMAT_OUTLINE: FT_Glyph_Format_ = 1869968492;
pub const FT_Glyph_Format__FT_GLYPH_FORMAT_PLOTTER: FT_Glyph_Format_ = 1886154612;
pub const FT_Glyph_Format__FT_GLYPH_FORMAT_SVG: FT_Glyph_Format_ = 1398163232;
#[doc = " @enum:\n   FT_Glyph_Format\n\n @description:\n   An enumeration type used to describe the format of a given glyph\n   image.  Note that this version of FreeType only supports two image\n   formats, even though future font drivers will be able to register\n   their own format.\n\n @values:\n   FT_GLYPH_FORMAT_NONE ::\n     The value~0 is reserved.\n\n   FT_GLYPH_FORMAT_COMPOSITE ::\n     The glyph image is a composite of several other images.  This format\n     is _only_ used with @FT_LOAD_NO_RECURSE, and is used to report\n     compound glyphs (like accented characters).\n\n   FT_GLYPH_FORMAT_BITMAP ::\n     The glyph image is a bitmap, and can be described as an @FT_Bitmap.\n     You generally need to access the `bitmap` field of the\n     @FT_GlyphSlotRec structure to read it.\n\n   FT_GLYPH_FORMAT_OUTLINE ::\n     The glyph image is a vectorial outline made of line segments and\n     Bezier arcs; it can be described as an @FT_Outline; you generally\n     want to access the `outline` field of the @FT_GlyphSlotRec structure\n     to read it.\n\n   FT_GLYPH_FORMAT_PLOTTER ::\n     The glyph image is a vectorial path with no inside and outside\n     contours.  Some Type~1 fonts, like those in the Hershey family,\n     contain glyphs in this format.  These are described as @FT_Outline,\n     but FreeType isn't currently capable of rendering them correctly.\n\n   FT_GLYPH_FORMAT_SVG ::\n     [Since 2.12] The glyph is represented by an SVG document in the\n     'SVG~' table."]
pub type FT_Glyph_Format_ = ::std::os::raw::c_uint;
#[doc = " @enum:\n   FT_Glyph_Format\n\n @description:\n   An enumeration type used to describe the format of a given glyph\n   image.  Note that this version of FreeType only supports two image\n   formats, even though future font drivers will be able to register\n   their own format.\n\n @values:\n   FT_GLYPH_FORMAT_NONE ::\n     The value~0 is reserved.\n\n   FT_GLYPH_FORMAT_COMPOSITE ::\n     The glyph image is a composite of several other images.  This format\n     is _only_ used with @FT_LOAD_NO_RECURSE, and is used to report\n     compound glyphs (like accented characters).\n\n   FT_GLYPH_FORMAT_BITMAP ::\n     The glyph image is a bitmap, and can be described as an @FT_Bitmap.\n     You generally need to access the `bitmap` field of the\n     @FT_GlyphSlotRec structure to read it.\n\n   FT_GLYPH_FORMAT_OUTLINE ::\n     The glyph image is a vectorial outline made of line segments and\n     Bezier arcs; it can be described as an @FT_Outline; you generally\n     want to access the `outline` field of the @FT_GlyphSlotRec structure\n     to read it.\n\n   FT_GLYPH_FORMAT_PLOTTER ::\n     The glyph image is a vectorial path with no inside and outside\n     contours.  Some Type~1 fonts, like those in the Hershey family,\n     contain glyphs in this format.  These are described as @FT_Outline,\n     but FreeType isn't currently capable of rendering them correctly.\n\n   FT_GLYPH_FORMAT_SVG ::\n     [Since 2.12] The glyph is represented by an SVG document in the\n     'SVG~' table."]
pub use self::FT_Glyph_Format_ as FT_Glyph_Format;
#[doc = " @struct:\n   FT_Span\n\n @description:\n   A structure to model a single span of consecutive pixels when\n   rendering an anti-aliased bitmap.\n\n @fields:\n   x ::\n     The span's horizontal start position.\n\n   len ::\n     The span's length in pixels.\n\n   coverage ::\n     The span color/coverage, ranging from 0 (background) to 255\n     (foreground).\n\n @note:\n   This structure is used by the span drawing callback type named\n   @FT_SpanFunc that takes the y~coordinate of the span as a parameter.\n\n   The anti-aliased rasterizer produces coverage values from 0 to 255,\n   that is, from completely transparent to completely opaque."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Span_ {
    pub x: ::std::os::raw::c_short,
    pub len: ::std::os::raw::c_ushort,
    pub coverage: ::std::os::raw::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_Span_"][::std::mem::size_of::<FT_Span_>() - 6usize];
    ["Alignment of FT_Span_"][::std::mem::align_of::<FT_Span_>() - 2usize];
    ["Offset of field: FT_Span_::x"][::std::mem::offset_of!(FT_Span_, x) - 0usize];
    ["Offset of field: FT_Span_::len"][::std::mem::offset_of!(FT_Span_, len) - 2usize];
    ["Offset of field: FT_Span_::coverage"][::std::mem::offset_of!(FT_Span_, coverage) - 4usize];
};
#[doc = " @struct:\n   FT_Span\n\n @description:\n   A structure to model a single span of consecutive pixels when\n   rendering an anti-aliased bitmap.\n\n @fields:\n   x ::\n     The span's horizontal start position.\n\n   len ::\n     The span's length in pixels.\n\n   coverage ::\n     The span color/coverage, ranging from 0 (background) to 255\n     (foreground).\n\n @note:\n   This structure is used by the span drawing callback type named\n   @FT_SpanFunc that takes the y~coordinate of the span as a parameter.\n\n   The anti-aliased rasterizer produces coverage values from 0 to 255,\n   that is, from completely transparent to completely opaque."]
pub type FT_Span = FT_Span_;
#[doc = " @functype:\n   FT_SpanFunc\n\n @description:\n   A function used as a call-back by the anti-aliased renderer in order\n   to let client applications draw themselves the pixel spans on each\n   scan line.\n\n @input:\n   y ::\n     The scanline's upward y~coordinate.\n\n   count ::\n     The number of spans to draw on this scanline.\n\n   spans ::\n     A table of `count` spans to draw on the scanline.\n\n   user ::\n     User-supplied data that is passed to the callback.\n\n @note:\n   This callback allows client applications to directly render the spans\n   of the anti-aliased bitmap to any kind of surfaces.\n\n   This can be used to write anti-aliased outlines directly to a given\n   background bitmap using alpha compositing.  It can also be used for\n   oversampling and averaging."]
pub type FT_SpanFunc = ::std::option::Option<
    unsafe extern "C" fn(
        y: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        spans: *const FT_Span,
        user: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @functype:\n   FT_Raster_BitTest_Func\n\n @description:\n   Deprecated, unimplemented."]
pub type FT_Raster_BitTest_Func = ::std::option::Option<
    unsafe extern "C" fn(
        y: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        user: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functype:\n   FT_Raster_BitSet_Func\n\n @description:\n   Deprecated, unimplemented."]
pub type FT_Raster_BitSet_Func = ::std::option::Option<
    unsafe extern "C" fn(
        y: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        user: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @struct:\n   FT_Raster_Params\n\n @description:\n   A structure to hold the parameters used by a raster's render function,\n   passed as an argument to @FT_Outline_Render.\n\n @fields:\n   target ::\n     The target bitmap.\n\n   source ::\n     A pointer to the source glyph image (e.g., an @FT_Outline).\n\n   flags ::\n     The rendering flags.\n\n   gray_spans ::\n     The gray span drawing callback.\n\n   black_spans ::\n     Unused.\n\n   bit_test ::\n     Unused.\n\n   bit_set ::\n     Unused.\n\n   user ::\n     User-supplied data that is passed to each drawing callback.\n\n   clip_box ::\n     An optional span clipping box expressed in _integer_ pixels\n     (not in 26.6 fixed-point units).\n\n @note:\n   The @FT_RASTER_FLAG_AA bit flag must be set in the `flags` to\n   generate an anti-aliased glyph bitmap, otherwise a monochrome bitmap\n   is generated.  The `target` should have appropriate pixel mode and its\n   dimensions define the clipping region.\n\n   If both @FT_RASTER_FLAG_AA and @FT_RASTER_FLAG_DIRECT bit flags\n   are set in `flags`, the raster calls an @FT_SpanFunc callback\n   `gray_spans` with `user` data as an argument ignoring `target`.  This\n   allows direct composition over a pre-existing user surface to perform\n   the span drawing and composition.  To optionally clip the spans, set\n   the @FT_RASTER_FLAG_CLIP flag and `clip_box`.  The monochrome raster\n   does not support the direct mode.\n\n   The gray-level rasterizer always uses 256 gray levels.  If you want\n   fewer gray levels, you have to use @FT_RASTER_FLAG_DIRECT and reduce\n   the levels in the callback function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Raster_Params_ {
    pub target: *const FT_Bitmap,
    pub source: *const ::std::os::raw::c_void,
    pub flags: ::std::os::raw::c_int,
    pub gray_spans: FT_SpanFunc,
    pub black_spans: FT_SpanFunc,
    pub bit_test: FT_Raster_BitTest_Func,
    pub bit_set: FT_Raster_BitSet_Func,
    pub user: *mut ::std::os::raw::c_void,
    pub clip_box: FT_BBox,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_Raster_Params_"][::std::mem::size_of::<FT_Raster_Params_>() - 96usize];
    ["Alignment of FT_Raster_Params_"][::std::mem::align_of::<FT_Raster_Params_>() - 8usize];
    ["Offset of field: FT_Raster_Params_::target"]
        [::std::mem::offset_of!(FT_Raster_Params_, target) - 0usize];
    ["Offset of field: FT_Raster_Params_::source"]
        [::std::mem::offset_of!(FT_Raster_Params_, source) - 8usize];
    ["Offset of field: FT_Raster_Params_::flags"]
        [::std::mem::offset_of!(FT_Raster_Params_, flags) - 16usize];
    ["Offset of field: FT_Raster_Params_::gray_spans"]
        [::std::mem::offset_of!(FT_Raster_Params_, gray_spans) - 24usize];
    ["Offset of field: FT_Raster_Params_::black_spans"]
        [::std::mem::offset_of!(FT_Raster_Params_, black_spans) - 32usize];
    ["Offset of field: FT_Raster_Params_::bit_test"]
        [::std::mem::offset_of!(FT_Raster_Params_, bit_test) - 40usize];
    ["Offset of field: FT_Raster_Params_::bit_set"]
        [::std::mem::offset_of!(FT_Raster_Params_, bit_set) - 48usize];
    ["Offset of field: FT_Raster_Params_::user"]
        [::std::mem::offset_of!(FT_Raster_Params_, user) - 56usize];
    ["Offset of field: FT_Raster_Params_::clip_box"]
        [::std::mem::offset_of!(FT_Raster_Params_, clip_box) - 64usize];
};
#[doc = " @struct:\n   FT_Raster_Params\n\n @description:\n   A structure to hold the parameters used by a raster's render function,\n   passed as an argument to @FT_Outline_Render.\n\n @fields:\n   target ::\n     The target bitmap.\n\n   source ::\n     A pointer to the source glyph image (e.g., an @FT_Outline).\n\n   flags ::\n     The rendering flags.\n\n   gray_spans ::\n     The gray span drawing callback.\n\n   black_spans ::\n     Unused.\n\n   bit_test ::\n     Unused.\n\n   bit_set ::\n     Unused.\n\n   user ::\n     User-supplied data that is passed to each drawing callback.\n\n   clip_box ::\n     An optional span clipping box expressed in _integer_ pixels\n     (not in 26.6 fixed-point units).\n\n @note:\n   The @FT_RASTER_FLAG_AA bit flag must be set in the `flags` to\n   generate an anti-aliased glyph bitmap, otherwise a monochrome bitmap\n   is generated.  The `target` should have appropriate pixel mode and its\n   dimensions define the clipping region.\n\n   If both @FT_RASTER_FLAG_AA and @FT_RASTER_FLAG_DIRECT bit flags\n   are set in `flags`, the raster calls an @FT_SpanFunc callback\n   `gray_spans` with `user` data as an argument ignoring `target`.  This\n   allows direct composition over a pre-existing user surface to perform\n   the span drawing and composition.  To optionally clip the spans, set\n   the @FT_RASTER_FLAG_CLIP flag and `clip_box`.  The monochrome raster\n   does not support the direct mode.\n\n   The gray-level rasterizer always uses 256 gray levels.  If you want\n   fewer gray levels, you have to use @FT_RASTER_FLAG_DIRECT and reduce\n   the levels in the callback function."]
pub type FT_Raster_Params = FT_Raster_Params_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_RasterRec_ {
    _unused: [u8; 0],
}
#[doc = " @type:\n   FT_Raster\n\n @description:\n   An opaque handle (pointer) to a raster object.  Each object can be\n   used independently to convert an outline into a bitmap or pixmap.\n\n @note:\n   In FreeType 2, all rasters are now encapsulated within specific\n   @FT_Renderer modules and only used in their context.\n"]
pub type FT_Raster = *mut FT_RasterRec_;
#[doc = " @functype:\n   FT_Raster_NewFunc\n\n @description:\n   A function used to create a new raster object.\n\n @input:\n   memory ::\n     A handle to the memory allocator.\n\n @output:\n   raster ::\n     A handle to the new raster object.\n\n @return:\n   Error code.  0~means success.\n\n @note:\n   The `memory` parameter is a typeless pointer in order to avoid\n   un-wanted dependencies on the rest of the FreeType code.  In practice,\n   it is an @FT_Memory object, i.e., a handle to the standard FreeType\n   memory allocator.  However, this field can be completely ignored by a\n   given raster implementation."]
pub type FT_Raster_NewFunc = ::std::option::Option<
    unsafe extern "C" fn(
        memory: *mut ::std::os::raw::c_void,
        raster: *mut FT_Raster,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functype:\n   FT_Raster_DoneFunc\n\n @description:\n   A function used to destroy a given raster object.\n\n @input:\n   raster ::\n     A handle to the raster object."]
pub type FT_Raster_DoneFunc = ::std::option::Option<unsafe extern "C" fn(raster: FT_Raster)>;
#[doc = " @functype:\n   FT_Raster_ResetFunc\n\n @description:\n   FreeType used to provide an area of memory called the 'render pool'\n   available to all registered rasterizers.  This was not thread safe,\n   however, and now FreeType never allocates this pool.\n\n   This function is called after a new raster object is created.\n\n @input:\n   raster ::\n     A handle to the new raster object.\n\n   pool_base ::\n     Previously, the address in memory of the render pool.  Set this to\n     `NULL`.\n\n   pool_size ::\n     Previously, the size in bytes of the render pool.  Set this to 0.\n\n @note:\n   Rasterizers should rely on dynamic or stack allocation if they want to\n   (a handle to the memory allocator is passed to the rasterizer\n   constructor)."]
pub type FT_Raster_ResetFunc = ::std::option::Option<
    unsafe extern "C" fn(
        raster: FT_Raster,
        pool_base: *mut ::std::os::raw::c_uchar,
        pool_size: ::std::os::raw::c_ulong,
    ),
>;
#[doc = " @functype:\n   FT_Raster_SetModeFunc\n\n @description:\n   This function is a generic facility to change modes or attributes in a\n   given raster.  This can be used for debugging purposes, or simply to\n   allow implementation-specific 'features' in a given raster module.\n\n @input:\n   raster ::\n     A handle to the new raster object.\n\n   mode ::\n     A 4-byte tag used to name the mode or property.\n\n   args ::\n     A pointer to the new mode/property to use."]
pub type FT_Raster_SetModeFunc = ::std::option::Option<
    unsafe extern "C" fn(
        raster: FT_Raster,
        mode: ::std::os::raw::c_ulong,
        args: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functype:\n   FT_Raster_RenderFunc\n\n @description:\n   Invoke a given raster to scan-convert a given glyph image into a\n   target bitmap.\n\n @input:\n   raster ::\n     A handle to the raster object.\n\n   params ::\n     A pointer to an @FT_Raster_Params structure used to store the\n     rendering parameters.\n\n @return:\n   Error code.  0~means success.\n\n @note:\n   The exact format of the source image depends on the raster's glyph\n   format defined in its @FT_Raster_Funcs structure.  It can be an\n   @FT_Outline or anything else in order to support a large array of\n   glyph formats.\n\n   Note also that the render function can fail and return a\n   `FT_Err_Unimplemented_Feature` error code if the raster used does not\n   support direct composition."]
pub type FT_Raster_RenderFunc = ::std::option::Option<
    unsafe extern "C" fn(
        raster: FT_Raster,
        params: *const FT_Raster_Params,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @struct:\n   FT_Raster_Funcs\n\n @description:\n  A structure used to describe a given raster class to the library.\n\n @fields:\n   glyph_format ::\n     The supported glyph format for this raster.\n\n   raster_new ::\n     The raster constructor.\n\n   raster_reset ::\n     Used to reset the render pool within the raster.\n\n   raster_render ::\n     A function to render a glyph into a given bitmap.\n\n   raster_done ::\n     The raster destructor."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Raster_Funcs_ {
    pub glyph_format: FT_Glyph_Format,
    pub raster_new: FT_Raster_NewFunc,
    pub raster_reset: FT_Raster_ResetFunc,
    pub raster_set_mode: FT_Raster_SetModeFunc,
    pub raster_render: FT_Raster_RenderFunc,
    pub raster_done: FT_Raster_DoneFunc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_Raster_Funcs_"][::std::mem::size_of::<FT_Raster_Funcs_>() - 48usize];
    ["Alignment of FT_Raster_Funcs_"][::std::mem::align_of::<FT_Raster_Funcs_>() - 8usize];
    ["Offset of field: FT_Raster_Funcs_::glyph_format"]
        [::std::mem::offset_of!(FT_Raster_Funcs_, glyph_format) - 0usize];
    ["Offset of field: FT_Raster_Funcs_::raster_new"]
        [::std::mem::offset_of!(FT_Raster_Funcs_, raster_new) - 8usize];
    ["Offset of field: FT_Raster_Funcs_::raster_reset"]
        [::std::mem::offset_of!(FT_Raster_Funcs_, raster_reset) - 16usize];
    ["Offset of field: FT_Raster_Funcs_::raster_set_mode"]
        [::std::mem::offset_of!(FT_Raster_Funcs_, raster_set_mode) - 24usize];
    ["Offset of field: FT_Raster_Funcs_::raster_render"]
        [::std::mem::offset_of!(FT_Raster_Funcs_, raster_render) - 32usize];
    ["Offset of field: FT_Raster_Funcs_::raster_done"]
        [::std::mem::offset_of!(FT_Raster_Funcs_, raster_done) - 40usize];
};
#[doc = " @struct:\n   FT_Raster_Funcs\n\n @description:\n  A structure used to describe a given raster class to the library.\n\n @fields:\n   glyph_format ::\n     The supported glyph format for this raster.\n\n   raster_new ::\n     The raster constructor.\n\n   raster_reset ::\n     Used to reset the render pool within the raster.\n\n   raster_render ::\n     A function to render a glyph into a given bitmap.\n\n   raster_done ::\n     The raster destructor."]
pub type FT_Raster_Funcs = FT_Raster_Funcs_;
#[doc = " @type:\n   FT_Bool\n\n @description:\n   A typedef of unsigned char, used for simple booleans.  As usual,\n   values 1 and~0 represent true and false, respectively."]
pub type FT_Bool = ::std::os::raw::c_uchar;
#[doc = " @type:\n   FT_FWord\n\n @description:\n   A signed 16-bit integer used to store a distance in original font\n   units."]
pub type FT_FWord = ::std::os::raw::c_short;
#[doc = " @type:\n   FT_UFWord\n\n @description:\n   An unsigned 16-bit integer used to store a distance in original font\n   units."]
pub type FT_UFWord = ::std::os::raw::c_ushort;
#[doc = " @type:\n   FT_Char\n\n @description:\n   A simple typedef for the _signed_ char type."]
pub type FT_Char = ::std::os::raw::c_schar;
#[doc = " @type:\n   FT_Byte\n\n @description:\n   A simple typedef for the _unsigned_ char type."]
pub type FT_Byte = ::std::os::raw::c_uchar;
#[doc = " @type:\n   FT_Bytes\n\n @description:\n   A typedef for constant memory areas."]
pub type FT_Bytes = *const FT_Byte;
#[doc = " @type:\n   FT_Tag\n\n @description:\n   A typedef for 32-bit tags (as used in the SFNT format)."]
pub type FT_Tag = FT_UInt32;
#[doc = " @type:\n   FT_String\n\n @description:\n   A simple typedef for the char type, usually used for strings."]
pub type FT_String = ::std::os::raw::c_char;
#[doc = " @type:\n   FT_Short\n\n @description:\n   A typedef for signed short."]
pub type FT_Short = ::std::os::raw::c_short;
#[doc = " @type:\n   FT_UShort\n\n @description:\n   A typedef for unsigned short."]
pub type FT_UShort = ::std::os::raw::c_ushort;
#[doc = " @type:\n   FT_Int\n\n @description:\n   A typedef for the int type."]
pub type FT_Int = ::std::os::raw::c_int;
#[doc = " @type:\n   FT_UInt\n\n @description:\n   A typedef for the unsigned int type."]
pub type FT_UInt = ::std::os::raw::c_uint;
#[doc = " @type:\n   FT_Long\n\n @description:\n   A typedef for signed long."]
pub type FT_Long = ::std::os::raw::c_long;
#[doc = " @type:\n   FT_ULong\n\n @description:\n   A typedef for unsigned long."]
pub type FT_ULong = ::std::os::raw::c_ulong;
#[doc = " @type:\n   FT_F2Dot14\n\n @description:\n   A signed 2.14 fixed-point type used for unit vectors."]
pub type FT_F2Dot14 = ::std::os::raw::c_short;
#[doc = " @type:\n   FT_F26Dot6\n\n @description:\n   A signed 26.6 fixed-point type used for vectorial pixel coordinates."]
pub type FT_F26Dot6 = ::std::os::raw::c_long;
#[doc = " @type:\n   FT_Fixed\n\n @description:\n   This type is used to store 16.16 fixed-point values, like scaling\n   values or matrix coefficients."]
pub type FT_Fixed = ::std::os::raw::c_long;
#[doc = " @type:\n   FT_Error\n\n @description:\n   The FreeType error code type.  A value of~0 is always interpreted as a\n   successful operation."]
pub type FT_Error = ::std::os::raw::c_int;
#[doc = " @type:\n   FT_Pointer\n\n @description:\n   A simple typedef for a typeless pointer."]
pub type FT_Pointer = *mut ::std::os::raw::c_void;
#[doc = " @type:\n   FT_Offset\n\n @description:\n   This is equivalent to the ANSI~C `size_t` type, i.e., the largest\n   _unsigned_ integer type used to express a file size or position, or a\n   memory block size."]
pub type FT_Offset = usize;
#[doc = " @type:\n   FT_PtrDist\n\n @description:\n   This is equivalent to the ANSI~C `ptrdiff_t` type, i.e., the largest\n   _signed_ integer type used to express the distance between two\n   pointers."]
pub type FT_PtrDist = isize;
#[doc = " @struct:\n   FT_UnitVector\n\n @description:\n   A simple structure used to store a 2D vector unit vector.  Uses\n   FT_F2Dot14 types.\n\n @fields:\n   x ::\n     Horizontal coordinate.\n\n   y ::\n     Vertical coordinate."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_UnitVector_ {
    pub x: FT_F2Dot14,
    pub y: FT_F2Dot14,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_UnitVector_"][::std::mem::size_of::<FT_UnitVector_>() - 4usize];
    ["Alignment of FT_UnitVector_"][::std::mem::align_of::<FT_UnitVector_>() - 2usize];
    ["Offset of field: FT_UnitVector_::x"][::std::mem::offset_of!(FT_UnitVector_, x) - 0usize];
    ["Offset of field: FT_UnitVector_::y"][::std::mem::offset_of!(FT_UnitVector_, y) - 2usize];
};
#[doc = " @struct:\n   FT_UnitVector\n\n @description:\n   A simple structure used to store a 2D vector unit vector.  Uses\n   FT_F2Dot14 types.\n\n @fields:\n   x ::\n     Horizontal coordinate.\n\n   y ::\n     Vertical coordinate."]
pub type FT_UnitVector = FT_UnitVector_;
#[doc = " @struct:\n   FT_Matrix\n\n @description:\n   A simple structure used to store a 2x2 matrix.  Coefficients are in\n   16.16 fixed-point format.  The computation performed is:\n\n   ```\n     x' = x*xx + y*xy\n     y' = x*yx + y*yy\n   ```\n\n @fields:\n   xx ::\n     Matrix coefficient.\n\n   xy ::\n     Matrix coefficient.\n\n   yx ::\n     Matrix coefficient.\n\n   yy ::\n     Matrix coefficient."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Matrix_ {
    pub xx: FT_Fixed,
    pub xy: FT_Fixed,
    pub yx: FT_Fixed,
    pub yy: FT_Fixed,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_Matrix_"][::std::mem::size_of::<FT_Matrix_>() - 32usize];
    ["Alignment of FT_Matrix_"][::std::mem::align_of::<FT_Matrix_>() - 8usize];
    ["Offset of field: FT_Matrix_::xx"][::std::mem::offset_of!(FT_Matrix_, xx) - 0usize];
    ["Offset of field: FT_Matrix_::xy"][::std::mem::offset_of!(FT_Matrix_, xy) - 8usize];
    ["Offset of field: FT_Matrix_::yx"][::std::mem::offset_of!(FT_Matrix_, yx) - 16usize];
    ["Offset of field: FT_Matrix_::yy"][::std::mem::offset_of!(FT_Matrix_, yy) - 24usize];
};
#[doc = " @struct:\n   FT_Matrix\n\n @description:\n   A simple structure used to store a 2x2 matrix.  Coefficients are in\n   16.16 fixed-point format.  The computation performed is:\n\n   ```\n     x' = x*xx + y*xy\n     y' = x*yx + y*yy\n   ```\n\n @fields:\n   xx ::\n     Matrix coefficient.\n\n   xy ::\n     Matrix coefficient.\n\n   yx ::\n     Matrix coefficient.\n\n   yy ::\n     Matrix coefficient."]
pub type FT_Matrix = FT_Matrix_;
#[doc = " @struct:\n   FT_Data\n\n @description:\n   Read-only binary data represented as a pointer and a length.\n\n @fields:\n   pointer ::\n     The data.\n\n   length ::\n     The length of the data in bytes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Data_ {
    pub pointer: *const FT_Byte,
    pub length: FT_UInt,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_Data_"][::std::mem::size_of::<FT_Data_>() - 16usize];
    ["Alignment of FT_Data_"][::std::mem::align_of::<FT_Data_>() - 8usize];
    ["Offset of field: FT_Data_::pointer"][::std::mem::offset_of!(FT_Data_, pointer) - 0usize];
    ["Offset of field: FT_Data_::length"][::std::mem::offset_of!(FT_Data_, length) - 8usize];
};
#[doc = " @struct:\n   FT_Data\n\n @description:\n   Read-only binary data represented as a pointer and a length.\n\n @fields:\n   pointer ::\n     The data.\n\n   length ::\n     The length of the data in bytes."]
pub type FT_Data = FT_Data_;
#[doc = " @functype:\n   FT_Generic_Finalizer\n\n @description:\n   Describe a function used to destroy the 'client' data of any FreeType\n   object.  See the description of the @FT_Generic type for details of\n   usage.\n\n @input:\n   The address of the FreeType object that is under finalization.  Its\n   client data is accessed through its `generic` field."]
pub type FT_Generic_Finalizer =
    ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void)>;
#[doc = " @struct:\n   FT_Generic\n\n @description:\n   Client applications often need to associate their own data to a\n   variety of FreeType core objects.  For example, a text layout API\n   might want to associate a glyph cache to a given size object.\n\n   Some FreeType object contains a `generic` field, of type `FT_Generic`,\n   which usage is left to client applications and font servers.\n\n   It can be used to store a pointer to client-specific data, as well as\n   the address of a 'finalizer' function, which will be called by\n   FreeType when the object is destroyed (for example, the previous\n   client example would put the address of the glyph cache destructor in\n   the `finalizer` field).\n\n @fields:\n   data ::\n     A typeless pointer to any client-specified data. This field is\n     completely ignored by the FreeType library.\n\n   finalizer ::\n     A pointer to a 'generic finalizer' function, which will be called\n     when the object is destroyed.  If this field is set to `NULL`, no\n     code will be called."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Generic_ {
    pub data: *mut ::std::os::raw::c_void,
    pub finalizer: FT_Generic_Finalizer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_Generic_"][::std::mem::size_of::<FT_Generic_>() - 16usize];
    ["Alignment of FT_Generic_"][::std::mem::align_of::<FT_Generic_>() - 8usize];
    ["Offset of field: FT_Generic_::data"][::std::mem::offset_of!(FT_Generic_, data) - 0usize];
    ["Offset of field: FT_Generic_::finalizer"]
        [::std::mem::offset_of!(FT_Generic_, finalizer) - 8usize];
};
#[doc = " @struct:\n   FT_Generic\n\n @description:\n   Client applications often need to associate their own data to a\n   variety of FreeType core objects.  For example, a text layout API\n   might want to associate a glyph cache to a given size object.\n\n   Some FreeType object contains a `generic` field, of type `FT_Generic`,\n   which usage is left to client applications and font servers.\n\n   It can be used to store a pointer to client-specific data, as well as\n   the address of a 'finalizer' function, which will be called by\n   FreeType when the object is destroyed (for example, the previous\n   client example would put the address of the glyph cache destructor in\n   the `finalizer` field).\n\n @fields:\n   data ::\n     A typeless pointer to any client-specified data. This field is\n     completely ignored by the FreeType library.\n\n   finalizer ::\n     A pointer to a 'generic finalizer' function, which will be called\n     when the object is destroyed.  If this field is set to `NULL`, no\n     code will be called."]
pub type FT_Generic = FT_Generic_;
#[doc = " @type:\n   FT_ListNode\n\n @description:\n    Many elements and objects in FreeType are listed through an @FT_List\n    record (see @FT_ListRec).  As its name suggests, an FT_ListNode is a\n    handle to a single list element."]
pub type FT_ListNode = *mut FT_ListNodeRec_;
#[doc = " @type:\n   FT_List\n\n @description:\n   A handle to a list record (see @FT_ListRec)."]
pub type FT_List = *mut FT_ListRec_;
#[doc = " @struct:\n   FT_ListNodeRec\n\n @description:\n   A structure used to hold a single list element.\n\n @fields:\n   prev ::\n     The previous element in the list.  `NULL` if first.\n\n   next ::\n     The next element in the list.  `NULL` if last.\n\n   data ::\n     A typeless pointer to the listed object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_ListNodeRec_ {
    pub prev: FT_ListNode,
    pub next: FT_ListNode,
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_ListNodeRec_"][::std::mem::size_of::<FT_ListNodeRec_>() - 24usize];
    ["Alignment of FT_ListNodeRec_"][::std::mem::align_of::<FT_ListNodeRec_>() - 8usize];
    ["Offset of field: FT_ListNodeRec_::prev"]
        [::std::mem::offset_of!(FT_ListNodeRec_, prev) - 0usize];
    ["Offset of field: FT_ListNodeRec_::next"]
        [::std::mem::offset_of!(FT_ListNodeRec_, next) - 8usize];
    ["Offset of field: FT_ListNodeRec_::data"]
        [::std::mem::offset_of!(FT_ListNodeRec_, data) - 16usize];
};
#[doc = " @struct:\n   FT_ListNodeRec\n\n @description:\n   A structure used to hold a single list element.\n\n @fields:\n   prev ::\n     The previous element in the list.  `NULL` if first.\n\n   next ::\n     The next element in the list.  `NULL` if last.\n\n   data ::\n     A typeless pointer to the listed object."]
pub type FT_ListNodeRec = FT_ListNodeRec_;
#[doc = " @struct:\n   FT_ListRec\n\n @description:\n   A structure used to hold a simple doubly-linked list.  These are used\n   in many parts of FreeType.\n\n @fields:\n   head ::\n     The head (first element) of doubly-linked list.\n\n   tail ::\n     The tail (last element) of doubly-linked list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_ListRec_ {
    pub head: FT_ListNode,
    pub tail: FT_ListNode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_ListRec_"][::std::mem::size_of::<FT_ListRec_>() - 16usize];
    ["Alignment of FT_ListRec_"][::std::mem::align_of::<FT_ListRec_>() - 8usize];
    ["Offset of field: FT_ListRec_::head"][::std::mem::offset_of!(FT_ListRec_, head) - 0usize];
    ["Offset of field: FT_ListRec_::tail"][::std::mem::offset_of!(FT_ListRec_, tail) - 8usize];
};
#[doc = " @struct:\n   FT_ListRec\n\n @description:\n   A structure used to hold a simple doubly-linked list.  These are used\n   in many parts of FreeType.\n\n @fields:\n   head ::\n     The head (first element) of doubly-linked list.\n\n   tail ::\n     The tail (last element) of doubly-linked list."]
pub type FT_ListRec = FT_ListRec_;
pub const FT_Mod_Err_Base: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Autofit: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_BDF: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Bzip2: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Cache: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_CFF: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_CID: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Gzip: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_LZW: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_OTvalid: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_PCF: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_PFR: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_PSaux: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_PShinter: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_PSnames: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Raster: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_SFNT: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Smooth: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_TrueType: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Type1: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Type42: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Winfonts: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_GXvalid: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Sdf: _bindgen_ty_1 = 0;
pub const FT_Mod_Err_Max: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const FT_Err_Ok: _bindgen_ty_2 = 0;
pub const FT_Err_Cannot_Open_Resource: _bindgen_ty_2 = 1;
pub const FT_Err_Unknown_File_Format: _bindgen_ty_2 = 2;
pub const FT_Err_Invalid_File_Format: _bindgen_ty_2 = 3;
pub const FT_Err_Invalid_Version: _bindgen_ty_2 = 4;
pub const FT_Err_Lower_Module_Version: _bindgen_ty_2 = 5;
pub const FT_Err_Invalid_Argument: _bindgen_ty_2 = 6;
pub const FT_Err_Unimplemented_Feature: _bindgen_ty_2 = 7;
pub const FT_Err_Invalid_Table: _bindgen_ty_2 = 8;
pub const FT_Err_Invalid_Offset: _bindgen_ty_2 = 9;
pub const FT_Err_Array_Too_Large: _bindgen_ty_2 = 10;
pub const FT_Err_Missing_Module: _bindgen_ty_2 = 11;
pub const FT_Err_Missing_Property: _bindgen_ty_2 = 12;
pub const FT_Err_Invalid_Glyph_Index: _bindgen_ty_2 = 16;
pub const FT_Err_Invalid_Character_Code: _bindgen_ty_2 = 17;
pub const FT_Err_Invalid_Glyph_Format: _bindgen_ty_2 = 18;
pub const FT_Err_Cannot_Render_Glyph: _bindgen_ty_2 = 19;
pub const FT_Err_Invalid_Outline: _bindgen_ty_2 = 20;
pub const FT_Err_Invalid_Composite: _bindgen_ty_2 = 21;
pub const FT_Err_Too_Many_Hints: _bindgen_ty_2 = 22;
pub const FT_Err_Invalid_Pixel_Size: _bindgen_ty_2 = 23;
pub const FT_Err_Invalid_SVG_Document: _bindgen_ty_2 = 24;
pub const FT_Err_Invalid_Handle: _bindgen_ty_2 = 32;
pub const FT_Err_Invalid_Library_Handle: _bindgen_ty_2 = 33;
pub const FT_Err_Invalid_Driver_Handle: _bindgen_ty_2 = 34;
pub const FT_Err_Invalid_Face_Handle: _bindgen_ty_2 = 35;
pub const FT_Err_Invalid_Size_Handle: _bindgen_ty_2 = 36;
pub const FT_Err_Invalid_Slot_Handle: _bindgen_ty_2 = 37;
pub const FT_Err_Invalid_CharMap_Handle: _bindgen_ty_2 = 38;
pub const FT_Err_Invalid_Cache_Handle: _bindgen_ty_2 = 39;
pub const FT_Err_Invalid_Stream_Handle: _bindgen_ty_2 = 40;
pub const FT_Err_Too_Many_Drivers: _bindgen_ty_2 = 48;
pub const FT_Err_Too_Many_Extensions: _bindgen_ty_2 = 49;
pub const FT_Err_Out_Of_Memory: _bindgen_ty_2 = 64;
pub const FT_Err_Unlisted_Object: _bindgen_ty_2 = 65;
pub const FT_Err_Cannot_Open_Stream: _bindgen_ty_2 = 81;
pub const FT_Err_Invalid_Stream_Seek: _bindgen_ty_2 = 82;
pub const FT_Err_Invalid_Stream_Skip: _bindgen_ty_2 = 83;
pub const FT_Err_Invalid_Stream_Read: _bindgen_ty_2 = 84;
pub const FT_Err_Invalid_Stream_Operation: _bindgen_ty_2 = 85;
pub const FT_Err_Invalid_Frame_Operation: _bindgen_ty_2 = 86;
pub const FT_Err_Nested_Frame_Access: _bindgen_ty_2 = 87;
pub const FT_Err_Invalid_Frame_Read: _bindgen_ty_2 = 88;
pub const FT_Err_Raster_Uninitialized: _bindgen_ty_2 = 96;
pub const FT_Err_Raster_Corrupted: _bindgen_ty_2 = 97;
pub const FT_Err_Raster_Overflow: _bindgen_ty_2 = 98;
pub const FT_Err_Raster_Negative_Height: _bindgen_ty_2 = 99;
pub const FT_Err_Too_Many_Caches: _bindgen_ty_2 = 112;
pub const FT_Err_Invalid_Opcode: _bindgen_ty_2 = 128;
pub const FT_Err_Too_Few_Arguments: _bindgen_ty_2 = 129;
pub const FT_Err_Stack_Overflow: _bindgen_ty_2 = 130;
pub const FT_Err_Code_Overflow: _bindgen_ty_2 = 131;
pub const FT_Err_Bad_Argument: _bindgen_ty_2 = 132;
pub const FT_Err_Divide_By_Zero: _bindgen_ty_2 = 133;
pub const FT_Err_Invalid_Reference: _bindgen_ty_2 = 134;
pub const FT_Err_Debug_OpCode: _bindgen_ty_2 = 135;
pub const FT_Err_ENDF_In_Exec_Stream: _bindgen_ty_2 = 136;
pub const FT_Err_Nested_DEFS: _bindgen_ty_2 = 137;
pub const FT_Err_Invalid_CodeRange: _bindgen_ty_2 = 138;
pub const FT_Err_Execution_Too_Long: _bindgen_ty_2 = 139;
pub const FT_Err_Too_Many_Function_Defs: _bindgen_ty_2 = 140;
pub const FT_Err_Too_Many_Instruction_Defs: _bindgen_ty_2 = 141;
pub const FT_Err_Table_Missing: _bindgen_ty_2 = 142;
pub const FT_Err_Horiz_Header_Missing: _bindgen_ty_2 = 143;
pub const FT_Err_Locations_Missing: _bindgen_ty_2 = 144;
pub const FT_Err_Name_Table_Missing: _bindgen_ty_2 = 145;
pub const FT_Err_CMap_Table_Missing: _bindgen_ty_2 = 146;
pub const FT_Err_Hmtx_Table_Missing: _bindgen_ty_2 = 147;
pub const FT_Err_Post_Table_Missing: _bindgen_ty_2 = 148;
pub const FT_Err_Invalid_Horiz_Metrics: _bindgen_ty_2 = 149;
pub const FT_Err_Invalid_CharMap_Format: _bindgen_ty_2 = 150;
pub const FT_Err_Invalid_PPem: _bindgen_ty_2 = 151;
pub const FT_Err_Invalid_Vert_Metrics: _bindgen_ty_2 = 152;
pub const FT_Err_Could_Not_Find_Context: _bindgen_ty_2 = 153;
pub const FT_Err_Invalid_Post_Table_Format: _bindgen_ty_2 = 154;
pub const FT_Err_Invalid_Post_Table: _bindgen_ty_2 = 155;
pub const FT_Err_DEF_In_Glyf_Bytecode: _bindgen_ty_2 = 156;
pub const FT_Err_Missing_Bitmap: _bindgen_ty_2 = 157;
pub const FT_Err_Missing_SVG_Hooks: _bindgen_ty_2 = 158;
pub const FT_Err_Syntax_Error: _bindgen_ty_2 = 160;
pub const FT_Err_Stack_Underflow: _bindgen_ty_2 = 161;
pub const FT_Err_Ignore: _bindgen_ty_2 = 162;
pub const FT_Err_No_Unicode_Glyph_Name: _bindgen_ty_2 = 163;
pub const FT_Err_Glyph_Too_Big: _bindgen_ty_2 = 164;
pub const FT_Err_Missing_Startfont_Field: _bindgen_ty_2 = 176;
pub const FT_Err_Missing_Font_Field: _bindgen_ty_2 = 177;
pub const FT_Err_Missing_Size_Field: _bindgen_ty_2 = 178;
pub const FT_Err_Missing_Fontboundingbox_Field: _bindgen_ty_2 = 179;
pub const FT_Err_Missing_Chars_Field: _bindgen_ty_2 = 180;
pub const FT_Err_Missing_Startchar_Field: _bindgen_ty_2 = 181;
pub const FT_Err_Missing_Encoding_Field: _bindgen_ty_2 = 182;
pub const FT_Err_Missing_Bbx_Field: _bindgen_ty_2 = 183;
pub const FT_Err_Bbx_Too_Big: _bindgen_ty_2 = 184;
pub const FT_Err_Corrupted_Font_Header: _bindgen_ty_2 = 185;
pub const FT_Err_Corrupted_Font_Glyphs: _bindgen_ty_2 = 186;
pub const FT_Err_Max: _bindgen_ty_2 = 187;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @function:\n   FT_Error_String\n\n @description:\n   Retrieve the description of a valid FreeType error code.\n\n @input:\n   error_code ::\n     A valid FreeType error code.\n\n @return:\n   A C~string or `NULL`, if any error occurred.\n\n @note:\n   FreeType has to be compiled with `FT_CONFIG_OPTION_ERROR_STRINGS` or\n   `FT_DEBUG_LEVEL_ERROR` to get meaningful descriptions.\n   'error_string' will be `NULL` otherwise.\n\n   Module identification will be ignored:\n\n   ```c\n     strcmp( FT_Error_String(  FT_Err_Unknown_File_Format ),\n             FT_Error_String( BDF_Err_Unknown_File_Format ) ) == 0;\n   ```"]
    pub fn FT_Error_String(error_code: FT_Error) -> *const ::std::os::raw::c_char;
}
#[doc = " @struct:\n   FT_Glyph_Metrics\n\n @description:\n   A structure to model the metrics of a single glyph.  The values are\n   expressed in 26.6 fractional pixel format; if the flag\n   @FT_LOAD_NO_SCALE has been used while loading the glyph, values are\n   expressed in font units instead.\n\n @fields:\n   width ::\n     The glyph's width.\n\n   height ::\n     The glyph's height.\n\n   horiBearingX ::\n     Left side bearing for horizontal layout.\n\n   horiBearingY ::\n     Top side bearing for horizontal layout.\n\n   horiAdvance ::\n     Advance width for horizontal layout.\n\n   vertBearingX ::\n     Left side bearing for vertical layout.\n\n   vertBearingY ::\n     Top side bearing for vertical layout.  Larger positive values mean\n     further below the vertical glyph origin.\n\n   vertAdvance ::\n     Advance height for vertical layout.  Positive values mean the glyph\n     has a positive advance downward.\n\n @note:\n   If not disabled with @FT_LOAD_NO_HINTING, the values represent\n   dimensions of the hinted glyph (in case hinting is applicable).\n\n   Stroking a glyph with an outside border does not increase\n   `horiAdvance` or `vertAdvance`; you have to manually adjust these\n   values to account for the added width and height.\n\n   FreeType doesn't use the 'VORG' table data for CFF fonts because it\n   doesn't have an interface to quickly retrieve the glyph height.  The\n   y~coordinate of the vertical origin can be simply computed as\n   `vertBearingY + height` after loading a glyph."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Glyph_Metrics_ {
    pub width: FT_Pos,
    pub height: FT_Pos,
    pub horiBearingX: FT_Pos,
    pub horiBearingY: FT_Pos,
    pub horiAdvance: FT_Pos,
    pub vertBearingX: FT_Pos,
    pub vertBearingY: FT_Pos,
    pub vertAdvance: FT_Pos,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_Glyph_Metrics_"][::std::mem::size_of::<FT_Glyph_Metrics_>() - 64usize];
    ["Alignment of FT_Glyph_Metrics_"][::std::mem::align_of::<FT_Glyph_Metrics_>() - 8usize];
    ["Offset of field: FT_Glyph_Metrics_::width"]
        [::std::mem::offset_of!(FT_Glyph_Metrics_, width) - 0usize];
    ["Offset of field: FT_Glyph_Metrics_::height"]
        [::std::mem::offset_of!(FT_Glyph_Metrics_, height) - 8usize];
    ["Offset of field: FT_Glyph_Metrics_::horiBearingX"]
        [::std::mem::offset_of!(FT_Glyph_Metrics_, horiBearingX) - 16usize];
    ["Offset of field: FT_Glyph_Metrics_::horiBearingY"]
        [::std::mem::offset_of!(FT_Glyph_Metrics_, horiBearingY) - 24usize];
    ["Offset of field: FT_Glyph_Metrics_::horiAdvance"]
        [::std::mem::offset_of!(FT_Glyph_Metrics_, horiAdvance) - 32usize];
    ["Offset of field: FT_Glyph_Metrics_::vertBearingX"]
        [::std::mem::offset_of!(FT_Glyph_Metrics_, vertBearingX) - 40usize];
    ["Offset of field: FT_Glyph_Metrics_::vertBearingY"]
        [::std::mem::offset_of!(FT_Glyph_Metrics_, vertBearingY) - 48usize];
    ["Offset of field: FT_Glyph_Metrics_::vertAdvance"]
        [::std::mem::offset_of!(FT_Glyph_Metrics_, vertAdvance) - 56usize];
};
#[doc = " @struct:\n   FT_Glyph_Metrics\n\n @description:\n   A structure to model the metrics of a single glyph.  The values are\n   expressed in 26.6 fractional pixel format; if the flag\n   @FT_LOAD_NO_SCALE has been used while loading the glyph, values are\n   expressed in font units instead.\n\n @fields:\n   width ::\n     The glyph's width.\n\n   height ::\n     The glyph's height.\n\n   horiBearingX ::\n     Left side bearing for horizontal layout.\n\n   horiBearingY ::\n     Top side bearing for horizontal layout.\n\n   horiAdvance ::\n     Advance width for horizontal layout.\n\n   vertBearingX ::\n     Left side bearing for vertical layout.\n\n   vertBearingY ::\n     Top side bearing for vertical layout.  Larger positive values mean\n     further below the vertical glyph origin.\n\n   vertAdvance ::\n     Advance height for vertical layout.  Positive values mean the glyph\n     has a positive advance downward.\n\n @note:\n   If not disabled with @FT_LOAD_NO_HINTING, the values represent\n   dimensions of the hinted glyph (in case hinting is applicable).\n\n   Stroking a glyph with an outside border does not increase\n   `horiAdvance` or `vertAdvance`; you have to manually adjust these\n   values to account for the added width and height.\n\n   FreeType doesn't use the 'VORG' table data for CFF fonts because it\n   doesn't have an interface to quickly retrieve the glyph height.  The\n   y~coordinate of the vertical origin can be simply computed as\n   `vertBearingY + height` after loading a glyph."]
pub type FT_Glyph_Metrics = FT_Glyph_Metrics_;
#[doc = " @struct:\n   FT_Bitmap_Size\n\n @description:\n   This structure models the metrics of a bitmap strike (i.e., a set of\n   glyphs for a given point size and resolution) in a bitmap font.  It is\n   used for the `available_sizes` field of @FT_Face.\n\n @fields:\n   height ::\n     The vertical distance, in pixels, between two consecutive baselines.\n     It is always positive.\n\n   width ::\n     The average width, in pixels, of all glyphs in the strike.\n\n   size ::\n     The nominal size of the strike in 26.6 fractional points.  This\n     field is not very useful.\n\n   x_ppem ::\n     The horizontal ppem (nominal width) in 26.6 fractional pixels.\n\n   y_ppem ::\n     The vertical ppem (nominal height) in 26.6 fractional pixels.\n\n @note:\n   Windows FNT:\n     The nominal size given in a FNT font is not reliable.  If the driver\n     finds it incorrect, it sets `size` to some calculated values, and\n     `x_ppem` and `y_ppem` to the pixel width and height given in the\n     font, respectively.\n\n   TrueType embedded bitmaps:\n     `size`, `width`, and `height` values are not contained in the bitmap\n     strike itself.  They are computed from the global font parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Bitmap_Size_ {
    pub height: FT_Short,
    pub width: FT_Short,
    pub size: FT_Pos,
    pub x_ppem: FT_Pos,
    pub y_ppem: FT_Pos,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_Bitmap_Size_"][::std::mem::size_of::<FT_Bitmap_Size_>() - 32usize];
    ["Alignment of FT_Bitmap_Size_"][::std::mem::align_of::<FT_Bitmap_Size_>() - 8usize];
    ["Offset of field: FT_Bitmap_Size_::height"]
        [::std::mem::offset_of!(FT_Bitmap_Size_, height) - 0usize];
    ["Offset of field: FT_Bitmap_Size_::width"]
        [::std::mem::offset_of!(FT_Bitmap_Size_, width) - 2usize];
    ["Offset of field: FT_Bitmap_Size_::size"]
        [::std::mem::offset_of!(FT_Bitmap_Size_, size) - 8usize];
    ["Offset of field: FT_Bitmap_Size_::x_ppem"]
        [::std::mem::offset_of!(FT_Bitmap_Size_, x_ppem) - 16usize];
    ["Offset of field: FT_Bitmap_Size_::y_ppem"]
        [::std::mem::offset_of!(FT_Bitmap_Size_, y_ppem) - 24usize];
};
#[doc = " @struct:\n   FT_Bitmap_Size\n\n @description:\n   This structure models the metrics of a bitmap strike (i.e., a set of\n   glyphs for a given point size and resolution) in a bitmap font.  It is\n   used for the `available_sizes` field of @FT_Face.\n\n @fields:\n   height ::\n     The vertical distance, in pixels, between two consecutive baselines.\n     It is always positive.\n\n   width ::\n     The average width, in pixels, of all glyphs in the strike.\n\n   size ::\n     The nominal size of the strike in 26.6 fractional points.  This\n     field is not very useful.\n\n   x_ppem ::\n     The horizontal ppem (nominal width) in 26.6 fractional pixels.\n\n   y_ppem ::\n     The vertical ppem (nominal height) in 26.6 fractional pixels.\n\n @note:\n   Windows FNT:\n     The nominal size given in a FNT font is not reliable.  If the driver\n     finds it incorrect, it sets `size` to some calculated values, and\n     `x_ppem` and `y_ppem` to the pixel width and height given in the\n     font, respectively.\n\n   TrueType embedded bitmaps:\n     `size`, `width`, and `height` values are not contained in the bitmap\n     strike itself.  They are computed from the global font parameters."]
pub type FT_Bitmap_Size = FT_Bitmap_Size_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_LibraryRec_ {
    _unused: [u8; 0],
}
#[doc = " @type:\n   FT_Library\n\n @description:\n   A handle to a FreeType library instance.  Each 'library' is completely\n   independent from the others; it is the 'root' of a set of objects like\n   fonts, faces, sizes, etc.\n\n   It also embeds a memory manager (see @FT_Memory), as well as a\n   scan-line converter object (see @FT_Raster).\n\n   [Since 2.5.6] In multi-threaded applications it is easiest to use one\n   `FT_Library` object per thread.  In case this is too cumbersome, a\n   single `FT_Library` object across threads is possible also, as long as\n   a mutex lock is used around @FT_New_Face and @FT_Done_Face.\n\n @note:\n   Library objects are normally created by @FT_Init_FreeType, and\n   destroyed with @FT_Done_FreeType.  If you need reference-counting\n   (cf. @FT_Reference_Library), use @FT_New_Library and @FT_Done_Library."]
pub type FT_Library = *mut FT_LibraryRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_ModuleRec_ {
    _unused: [u8; 0],
}
#[doc = " @type:\n   FT_Module\n\n @description:\n   A handle to a given FreeType module object.  A module can be a font\n   driver, a renderer, or anything else that provides services to the\n   former."]
pub type FT_Module = *mut FT_ModuleRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_DriverRec_ {
    _unused: [u8; 0],
}
#[doc = " @type:\n   FT_Driver\n\n @description:\n   A handle to a given FreeType font driver object.  A font driver is a\n   module capable of creating faces from font files."]
pub type FT_Driver = *mut FT_DriverRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_RendererRec_ {
    _unused: [u8; 0],
}
#[doc = " @type:\n   FT_Renderer\n\n @description:\n   A handle to a given FreeType renderer.  A renderer is a module in\n   charge of converting a glyph's outline image to a bitmap.  It supports\n   a single glyph image format, and one or more target surface depths."]
pub type FT_Renderer = *mut FT_RendererRec_;
#[doc = " @type:\n   FT_Face\n\n @description:\n   A handle to a typographic face object.  A face object models a given\n   typeface, in a given style.\n\n @note:\n   A face object also owns a single @FT_GlyphSlot object, as well as one\n   or more @FT_Size objects.\n\n   Use @FT_New_Face or @FT_Open_Face to create a new face object from a\n   given filepath or a custom input stream.\n\n   Use @FT_Done_Face to destroy it (along with its slot and sizes).\n\n   An `FT_Face` object can only be safely used from one thread at a time.\n   Similarly, creation and destruction of `FT_Face` with the same\n   @FT_Library object can only be done from one thread at a time.  On the\n   other hand, functions like @FT_Load_Glyph and its siblings are\n   thread-safe and do not need the lock to be held as long as the same\n   `FT_Face` object is not used from multiple threads at the same time.\n\n @also:\n   See @FT_FaceRec for the publicly accessible fields of a given face\n   object."]
pub type FT_Face = *mut FT_FaceRec_;
#[doc = " @type:\n   FT_Size\n\n @description:\n   A handle to an object that models a face scaled to a given character\n   size.\n\n @note:\n   An @FT_Face has one _active_ `FT_Size` object that is used by\n   functions like @FT_Load_Glyph to determine the scaling transformation\n   that in turn is used to load and hint glyphs and metrics.\n\n   A newly created `FT_Size` object contains only meaningless zero values.\n   You must use @FT_Set_Char_Size, @FT_Set_Pixel_Sizes, @FT_Request_Size\n   or even @FT_Select_Size to change the content (i.e., the scaling\n   values) of the active `FT_Size`.  Otherwise, the scaling and hinting\n   will not be performed.\n\n   You can use @FT_New_Size to create additional size objects for a given\n   @FT_Face, but they won't be used by other functions until you activate\n   it through @FT_Activate_Size.  Only one size can be activated at any\n   given time per face.\n\n @also:\n   See @FT_SizeRec for the publicly accessible fields of a given size\n   object."]
pub type FT_Size = *mut FT_SizeRec_;
#[doc = " @type:\n   FT_GlyphSlot\n\n @description:\n   A handle to a given 'glyph slot'.  A slot is a container that can hold\n   any of the glyphs contained in its parent face.\n\n   In other words, each time you call @FT_Load_Glyph or @FT_Load_Char,\n   the slot's content is erased by the new glyph data, i.e., the glyph's\n   metrics, its image (bitmap or outline), and other control information.\n\n @also:\n   See @FT_GlyphSlotRec for the publicly accessible glyph fields."]
pub type FT_GlyphSlot = *mut FT_GlyphSlotRec_;
#[doc = " @type:\n   FT_CharMap\n\n @description:\n   A handle to a character map (usually abbreviated to 'charmap').  A\n   charmap is used to translate character codes in a given encoding into\n   glyph indexes for its parent's face.  Some font formats may provide\n   several charmaps per font.\n\n   Each face object owns zero or more charmaps, but only one of them can\n   be 'active', providing the data used by @FT_Get_Char_Index or\n   @FT_Load_Char.\n\n   The list of available charmaps in a face is available through the\n   `face->num_charmaps` and `face->charmaps` fields of @FT_FaceRec.\n\n   The currently active charmap is available as `face->charmap`.  You\n   should call @FT_Set_Charmap to change it.\n\n @note:\n   When a new face is created (either through @FT_New_Face or\n   @FT_Open_Face), the library looks for a Unicode charmap within the\n   list and automatically activates it.  If there is no Unicode charmap,\n   FreeType doesn't set an 'active' charmap.\n\n @also:\n   See @FT_CharMapRec for the publicly accessible fields of a given\n   character map."]
pub type FT_CharMap = *mut FT_CharMapRec_;
pub const FT_Encoding__FT_ENCODING_NONE: FT_Encoding_ = 0;
pub const FT_Encoding__FT_ENCODING_MS_SYMBOL: FT_Encoding_ = 1937337698;
pub const FT_Encoding__FT_ENCODING_UNICODE: FT_Encoding_ = 1970170211;
pub const FT_Encoding__FT_ENCODING_SJIS: FT_Encoding_ = 1936353651;
pub const FT_Encoding__FT_ENCODING_PRC: FT_Encoding_ = 1734484000;
pub const FT_Encoding__FT_ENCODING_BIG5: FT_Encoding_ = 1651074869;
pub const FT_Encoding__FT_ENCODING_WANSUNG: FT_Encoding_ = 2002873971;
pub const FT_Encoding__FT_ENCODING_JOHAB: FT_Encoding_ = 1785686113;
pub const FT_Encoding__FT_ENCODING_GB2312: FT_Encoding_ = 1734484000;
pub const FT_Encoding__FT_ENCODING_MS_SJIS: FT_Encoding_ = 1936353651;
pub const FT_Encoding__FT_ENCODING_MS_GB2312: FT_Encoding_ = 1734484000;
pub const FT_Encoding__FT_ENCODING_MS_BIG5: FT_Encoding_ = 1651074869;
pub const FT_Encoding__FT_ENCODING_MS_WANSUNG: FT_Encoding_ = 2002873971;
pub const FT_Encoding__FT_ENCODING_MS_JOHAB: FT_Encoding_ = 1785686113;
pub const FT_Encoding__FT_ENCODING_ADOBE_STANDARD: FT_Encoding_ = 1094995778;
pub const FT_Encoding__FT_ENCODING_ADOBE_EXPERT: FT_Encoding_ = 1094992453;
pub const FT_Encoding__FT_ENCODING_ADOBE_CUSTOM: FT_Encoding_ = 1094992451;
pub const FT_Encoding__FT_ENCODING_ADOBE_LATIN_1: FT_Encoding_ = 1818326065;
pub const FT_Encoding__FT_ENCODING_OLD_LATIN_2: FT_Encoding_ = 1818326066;
pub const FT_Encoding__FT_ENCODING_APPLE_ROMAN: FT_Encoding_ = 1634889070;
#[doc = " @enum:\n   FT_Encoding\n\n @description:\n   An enumeration to specify character sets supported by charmaps.  Used\n   in the @FT_Select_Charmap API function.\n\n @note:\n   Despite the name, this enumeration lists specific character\n   repertoires (i.e., charsets), and not text encoding methods (e.g.,\n   UTF-8, UTF-16, etc.).\n\n   Other encodings might be defined in the future.\n\n @values:\n   FT_ENCODING_NONE ::\n     The encoding value~0 is reserved for all formats except BDF, PCF,\n     and Windows FNT; see below for more information.\n\n   FT_ENCODING_UNICODE ::\n     The Unicode character set.  This value covers all versions of the\n     Unicode repertoire, including ASCII and Latin-1.  Most fonts include\n     a Unicode charmap, but not all of them.\n\n     For example, if you want to access Unicode value U+1F028 (and the\n     font contains it), use value 0x1F028 as the input value for\n     @FT_Get_Char_Index.\n\n   FT_ENCODING_MS_SYMBOL ::\n     Microsoft Symbol encoding, used to encode mathematical symbols and\n     wingdings.  For more information, see\n     'https://learn.microsoft.com/typography/opentype/spec/recom#non-standard-symbol-fonts',\n     'http://www.kostis.net/charsets/symbol.htm', and\n     'http://www.kostis.net/charsets/wingding.htm'.\n\n     This encoding uses character codes from the PUA (Private Unicode\n     Area) in the range U+F020-U+F0FF.\n\n   FT_ENCODING_SJIS ::\n     Shift JIS encoding for Japanese.  More info at\n     'https://en.wikipedia.org/wiki/Shift_JIS'.  See note on multi-byte\n     encodings below.\n\n   FT_ENCODING_PRC ::\n     Corresponds to encoding systems mainly for Simplified Chinese as\n     used in People's Republic of China (PRC).  The encoding layout is\n     based on GB~2312 and its supersets GBK and GB~18030.\n\n   FT_ENCODING_BIG5 ::\n     Corresponds to an encoding system for Traditional Chinese as used in\n     Taiwan and Hong Kong.\n\n   FT_ENCODING_WANSUNG ::\n     Corresponds to the Korean encoding system known as Extended Wansung\n     (MS Windows code page 949).  For more information see\n     'https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/bestfit949.txt'.\n\n   FT_ENCODING_JOHAB ::\n     The Korean standard character set (KS~C 5601-1992), which\n     corresponds to MS Windows code page 1361.  This character set\n     includes all possible Hangul character combinations.\n\n   FT_ENCODING_ADOBE_LATIN_1 ::\n     Corresponds to a Latin-1 encoding as defined in a Type~1 PostScript\n     font.  It is limited to 256 character codes.\n\n   FT_ENCODING_ADOBE_STANDARD ::\n     Adobe Standard encoding, as found in Type~1, CFF, and OpenType/CFF\n     fonts.  It is limited to 256 character codes.\n\n   FT_ENCODING_ADOBE_EXPERT ::\n     Adobe Expert encoding, as found in Type~1, CFF, and OpenType/CFF\n     fonts.  It is limited to 256 character codes.\n\n   FT_ENCODING_ADOBE_CUSTOM ::\n     Corresponds to a custom encoding, as found in Type~1, CFF, and\n     OpenType/CFF fonts.  It is limited to 256 character codes.\n\n   FT_ENCODING_APPLE_ROMAN ::\n     Apple roman encoding.  Many TrueType and OpenType fonts contain a\n     charmap for this 8-bit encoding, since older versions of Mac OS are\n     able to use it.\n\n   FT_ENCODING_OLD_LATIN_2 ::\n     This value is deprecated and was neither used nor reported by\n     FreeType.  Don't use or test for it.\n\n   FT_ENCODING_MS_SJIS ::\n     Same as FT_ENCODING_SJIS.  Deprecated.\n\n   FT_ENCODING_MS_GB2312 ::\n     Same as FT_ENCODING_PRC.  Deprecated.\n\n   FT_ENCODING_MS_BIG5 ::\n     Same as FT_ENCODING_BIG5.  Deprecated.\n\n   FT_ENCODING_MS_WANSUNG ::\n     Same as FT_ENCODING_WANSUNG.  Deprecated.\n\n   FT_ENCODING_MS_JOHAB ::\n     Same as FT_ENCODING_JOHAB.  Deprecated.\n\n @note:\n   When loading a font, FreeType makes a Unicode charmap active if\n   possible (either if the font provides such a charmap, or if FreeType\n   can synthesize one from PostScript glyph name dictionaries; in either\n   case, the charmap is tagged with `FT_ENCODING_UNICODE`).  If such a\n   charmap is synthesized, it is placed at the first position of the\n   charmap array.\n\n   All other encodings are considered legacy and tagged only if\n   explicitly defined in the font file.  Otherwise, `FT_ENCODING_NONE` is\n   used.\n\n   `FT_ENCODING_NONE` is set by the BDF and PCF drivers if the charmap is\n   neither Unicode nor ISO-8859-1 (otherwise it is set to\n   `FT_ENCODING_UNICODE`).  Use @FT_Get_BDF_Charset_ID to find out which\n   encoding is really present.  If, for example, the `cs_registry` field\n   is 'KOI8' and the `cs_encoding` field is 'R', the font is encoded in\n   KOI8-R.\n\n   `FT_ENCODING_NONE` is always set (with a single exception) by the\n   winfonts driver.  Use @FT_Get_WinFNT_Header and examine the `charset`\n   field of the @FT_WinFNT_HeaderRec structure to find out which encoding\n   is really present.  For example, @FT_WinFNT_ID_CP1251 (204) means\n   Windows code page 1251 (for Russian).\n\n   `FT_ENCODING_NONE` is set if `platform_id` is @TT_PLATFORM_MACINTOSH\n   and `encoding_id` is not `TT_MAC_ID_ROMAN` (otherwise it is set to\n   `FT_ENCODING_APPLE_ROMAN`).\n\n   If `platform_id` is @TT_PLATFORM_MACINTOSH, use the function\n   @FT_Get_CMap_Language_ID to query the Mac language ID that may be\n   needed to be able to distinguish Apple encoding variants.  See\n\n     https://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\n\n   to get an idea how to do that.  Basically, if the language ID is~0,\n   don't use it, otherwise subtract 1 from the language ID.  Then examine\n   `encoding_id`.  If, for example, `encoding_id` is `TT_MAC_ID_ROMAN`\n   and the language ID (minus~1) is `TT_MAC_LANGID_GREEK`, it is the\n   Greek encoding, not Roman.  `TT_MAC_ID_ARABIC` with\n   `TT_MAC_LANGID_FARSI` means the Farsi variant of the Arabic encoding."]
pub type FT_Encoding_ = ::std::os::raw::c_uint;
#[doc = " @enum:\n   FT_Encoding\n\n @description:\n   An enumeration to specify character sets supported by charmaps.  Used\n   in the @FT_Select_Charmap API function.\n\n @note:\n   Despite the name, this enumeration lists specific character\n   repertoires (i.e., charsets), and not text encoding methods (e.g.,\n   UTF-8, UTF-16, etc.).\n\n   Other encodings might be defined in the future.\n\n @values:\n   FT_ENCODING_NONE ::\n     The encoding value~0 is reserved for all formats except BDF, PCF,\n     and Windows FNT; see below for more information.\n\n   FT_ENCODING_UNICODE ::\n     The Unicode character set.  This value covers all versions of the\n     Unicode repertoire, including ASCII and Latin-1.  Most fonts include\n     a Unicode charmap, but not all of them.\n\n     For example, if you want to access Unicode value U+1F028 (and the\n     font contains it), use value 0x1F028 as the input value for\n     @FT_Get_Char_Index.\n\n   FT_ENCODING_MS_SYMBOL ::\n     Microsoft Symbol encoding, used to encode mathematical symbols and\n     wingdings.  For more information, see\n     'https://learn.microsoft.com/typography/opentype/spec/recom#non-standard-symbol-fonts',\n     'http://www.kostis.net/charsets/symbol.htm', and\n     'http://www.kostis.net/charsets/wingding.htm'.\n\n     This encoding uses character codes from the PUA (Private Unicode\n     Area) in the range U+F020-U+F0FF.\n\n   FT_ENCODING_SJIS ::\n     Shift JIS encoding for Japanese.  More info at\n     'https://en.wikipedia.org/wiki/Shift_JIS'.  See note on multi-byte\n     encodings below.\n\n   FT_ENCODING_PRC ::\n     Corresponds to encoding systems mainly for Simplified Chinese as\n     used in People's Republic of China (PRC).  The encoding layout is\n     based on GB~2312 and its supersets GBK and GB~18030.\n\n   FT_ENCODING_BIG5 ::\n     Corresponds to an encoding system for Traditional Chinese as used in\n     Taiwan and Hong Kong.\n\n   FT_ENCODING_WANSUNG ::\n     Corresponds to the Korean encoding system known as Extended Wansung\n     (MS Windows code page 949).  For more information see\n     'https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/bestfit949.txt'.\n\n   FT_ENCODING_JOHAB ::\n     The Korean standard character set (KS~C 5601-1992), which\n     corresponds to MS Windows code page 1361.  This character set\n     includes all possible Hangul character combinations.\n\n   FT_ENCODING_ADOBE_LATIN_1 ::\n     Corresponds to a Latin-1 encoding as defined in a Type~1 PostScript\n     font.  It is limited to 256 character codes.\n\n   FT_ENCODING_ADOBE_STANDARD ::\n     Adobe Standard encoding, as found in Type~1, CFF, and OpenType/CFF\n     fonts.  It is limited to 256 character codes.\n\n   FT_ENCODING_ADOBE_EXPERT ::\n     Adobe Expert encoding, as found in Type~1, CFF, and OpenType/CFF\n     fonts.  It is limited to 256 character codes.\n\n   FT_ENCODING_ADOBE_CUSTOM ::\n     Corresponds to a custom encoding, as found in Type~1, CFF, and\n     OpenType/CFF fonts.  It is limited to 256 character codes.\n\n   FT_ENCODING_APPLE_ROMAN ::\n     Apple roman encoding.  Many TrueType and OpenType fonts contain a\n     charmap for this 8-bit encoding, since older versions of Mac OS are\n     able to use it.\n\n   FT_ENCODING_OLD_LATIN_2 ::\n     This value is deprecated and was neither used nor reported by\n     FreeType.  Don't use or test for it.\n\n   FT_ENCODING_MS_SJIS ::\n     Same as FT_ENCODING_SJIS.  Deprecated.\n\n   FT_ENCODING_MS_GB2312 ::\n     Same as FT_ENCODING_PRC.  Deprecated.\n\n   FT_ENCODING_MS_BIG5 ::\n     Same as FT_ENCODING_BIG5.  Deprecated.\n\n   FT_ENCODING_MS_WANSUNG ::\n     Same as FT_ENCODING_WANSUNG.  Deprecated.\n\n   FT_ENCODING_MS_JOHAB ::\n     Same as FT_ENCODING_JOHAB.  Deprecated.\n\n @note:\n   When loading a font, FreeType makes a Unicode charmap active if\n   possible (either if the font provides such a charmap, or if FreeType\n   can synthesize one from PostScript glyph name dictionaries; in either\n   case, the charmap is tagged with `FT_ENCODING_UNICODE`).  If such a\n   charmap is synthesized, it is placed at the first position of the\n   charmap array.\n\n   All other encodings are considered legacy and tagged only if\n   explicitly defined in the font file.  Otherwise, `FT_ENCODING_NONE` is\n   used.\n\n   `FT_ENCODING_NONE` is set by the BDF and PCF drivers if the charmap is\n   neither Unicode nor ISO-8859-1 (otherwise it is set to\n   `FT_ENCODING_UNICODE`).  Use @FT_Get_BDF_Charset_ID to find out which\n   encoding is really present.  If, for example, the `cs_registry` field\n   is 'KOI8' and the `cs_encoding` field is 'R', the font is encoded in\n   KOI8-R.\n\n   `FT_ENCODING_NONE` is always set (with a single exception) by the\n   winfonts driver.  Use @FT_Get_WinFNT_Header and examine the `charset`\n   field of the @FT_WinFNT_HeaderRec structure to find out which encoding\n   is really present.  For example, @FT_WinFNT_ID_CP1251 (204) means\n   Windows code page 1251 (for Russian).\n\n   `FT_ENCODING_NONE` is set if `platform_id` is @TT_PLATFORM_MACINTOSH\n   and `encoding_id` is not `TT_MAC_ID_ROMAN` (otherwise it is set to\n   `FT_ENCODING_APPLE_ROMAN`).\n\n   If `platform_id` is @TT_PLATFORM_MACINTOSH, use the function\n   @FT_Get_CMap_Language_ID to query the Mac language ID that may be\n   needed to be able to distinguish Apple encoding variants.  See\n\n     https://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\n\n   to get an idea how to do that.  Basically, if the language ID is~0,\n   don't use it, otherwise subtract 1 from the language ID.  Then examine\n   `encoding_id`.  If, for example, `encoding_id` is `TT_MAC_ID_ROMAN`\n   and the language ID (minus~1) is `TT_MAC_LANGID_GREEK`, it is the\n   Greek encoding, not Roman.  `TT_MAC_ID_ARABIC` with\n   `TT_MAC_LANGID_FARSI` means the Farsi variant of the Arabic encoding."]
pub use self::FT_Encoding_ as FT_Encoding;
#[doc = " @struct:\n   FT_CharMapRec\n\n @description:\n   The base charmap structure.\n\n @fields:\n   face ::\n     A handle to the parent face object.\n\n   encoding ::\n     An @FT_Encoding tag identifying the charmap.  Use this with\n     @FT_Select_Charmap.\n\n   platform_id ::\n     An ID number describing the platform for the following encoding ID.\n     This comes directly from the TrueType specification and gets\n     emulated for other formats.\n\n   encoding_id ::\n     A platform-specific encoding number.  This also comes from the\n     TrueType specification and gets emulated similarly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_CharMapRec_ {
    pub face: FT_Face,
    pub encoding: FT_Encoding,
    pub platform_id: FT_UShort,
    pub encoding_id: FT_UShort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_CharMapRec_"][::std::mem::size_of::<FT_CharMapRec_>() - 16usize];
    ["Alignment of FT_CharMapRec_"][::std::mem::align_of::<FT_CharMapRec_>() - 8usize];
    ["Offset of field: FT_CharMapRec_::face"]
        [::std::mem::offset_of!(FT_CharMapRec_, face) - 0usize];
    ["Offset of field: FT_CharMapRec_::encoding"]
        [::std::mem::offset_of!(FT_CharMapRec_, encoding) - 8usize];
    ["Offset of field: FT_CharMapRec_::platform_id"]
        [::std::mem::offset_of!(FT_CharMapRec_, platform_id) - 12usize];
    ["Offset of field: FT_CharMapRec_::encoding_id"]
        [::std::mem::offset_of!(FT_CharMapRec_, encoding_id) - 14usize];
};
#[doc = " @struct:\n   FT_CharMapRec\n\n @description:\n   The base charmap structure.\n\n @fields:\n   face ::\n     A handle to the parent face object.\n\n   encoding ::\n     An @FT_Encoding tag identifying the charmap.  Use this with\n     @FT_Select_Charmap.\n\n   platform_id ::\n     An ID number describing the platform for the following encoding ID.\n     This comes directly from the TrueType specification and gets\n     emulated for other formats.\n\n   encoding_id ::\n     A platform-specific encoding number.  This also comes from the\n     TrueType specification and gets emulated similarly."]
pub type FT_CharMapRec = FT_CharMapRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Face_InternalRec_ {
    _unused: [u8; 0],
}
#[doc = " @type:\n   FT_Face_Internal\n\n @description:\n   An opaque handle to an `FT_Face_InternalRec` structure that models the\n   private data of a given @FT_Face object.\n\n   This structure might change between releases of FreeType~2 and is not\n   generally available to client applications."]
pub type FT_Face_Internal = *mut FT_Face_InternalRec_;
#[doc = " @struct:\n   FT_FaceRec\n\n @description:\n   FreeType root face class structure.  A face object models a typeface\n   in a font file.\n\n @fields:\n   num_faces ::\n     The number of faces in the font file.  Some font formats can have\n     multiple faces in a single font file.\n\n   face_index ::\n     This field holds two different values.  Bits 0-15 are the index of\n     the face in the font file (starting with value~0).  They are set\n     to~0 if there is only one face in the font file.\n\n     [Since 2.6.1] Bits 16-30 are relevant to TrueType GX and OpenType\n     Font Variations only, holding the named instance index for the\n     current face index (starting with value~1; value~0 indicates font\n     access without a named instance).  For non-variation fonts, bits\n     16-30 are ignored.  If we have the third named instance of face~4,\n     say, `face_index` is set to 0x00030004.\n\n     Bit 31 is always zero (that is, `face_index` is always a positive\n     value).\n\n     [Since 2.9] Changing the design coordinates with\n     @FT_Set_Var_Design_Coordinates or @FT_Set_Var_Blend_Coordinates does\n     not influence the named instance index value (only\n     @FT_Set_Named_Instance does that).\n\n   face_flags ::\n     A set of bit flags that give important information about the face;\n     see @FT_FACE_FLAG_XXX for the details.\n\n   style_flags ::\n     The lower 16~bits contain a set of bit flags indicating the style of\n     the face; see @FT_STYLE_FLAG_XXX for the details.\n\n     [Since 2.6.1] Bits 16-30 hold the number of named instances\n     available for the current face if we have a TrueType GX or OpenType\n     Font Variation.  Bit 31 is always zero (that is, `style_flags` is\n     always a positive value).  Note that a variation font has always at\n     least one named instance, namely the default instance.\n\n   num_glyphs ::\n     The number of glyphs in the face.  If the face is scalable and has\n     sbits (see `num_fixed_sizes`), it is set to the number of outline\n     glyphs.\n\n     For CID-keyed fonts (not in an SFNT wrapper) this value gives the\n     highest CID used in the font.\n\n   family_name ::\n     The face's family name.  This is an ASCII string, usually in\n     English, that describes the typeface's family (like 'Times New\n     Roman', 'Bodoni', 'Garamond', etc).  This is a least common\n     denominator used to list fonts.  Some formats (TrueType & OpenType)\n     provide localized and Unicode versions of this string.  Applications\n     should use the format-specific interface to access them.  Can be\n     `NULL` (e.g., in fonts embedded in a PDF file).\n\n     In case the font doesn't provide a specific family name entry,\n     FreeType tries to synthesize one, deriving it from other name\n     entries.\n\n   style_name ::\n     The face's style name.  This is an ASCII string, usually in English,\n     that describes the typeface's style (like 'Italic', 'Bold',\n     'Condensed', etc).  Not all font formats provide a style name, so\n     this field is optional, and can be set to `NULL`.  As for\n     `family_name`, some formats provide localized and Unicode versions\n     of this string.  Applications should use the format-specific\n     interface to access them.\n\n   num_fixed_sizes ::\n     The number of bitmap strikes in the face.  Even if the face is\n     scalable, there might still be bitmap strikes, which are called\n     'sbits' in that case.\n\n   available_sizes ::\n     An array of @FT_Bitmap_Size for all bitmap strikes in the face.  It\n     is set to `NULL` if there is no bitmap strike.\n\n     Note that FreeType tries to sanitize the strike data since they are\n     sometimes sloppy or incorrect, but this can easily fail.\n\n   num_charmaps ::\n     The number of charmaps in the face.\n\n   charmaps ::\n     An array of the charmaps of the face.\n\n   generic ::\n     A field reserved for client uses.  See the @FT_Generic type\n     description.\n\n   bbox ::\n     The font bounding box.  Coordinates are expressed in font units (see\n     `units_per_EM`).  The box is large enough to contain any glyph from\n     the font.  Thus, `bbox.yMax` can be seen as the 'maximum ascender',\n     and `bbox.yMin` as the 'minimum descender'.  Only relevant for\n     scalable formats.\n\n     Note that the bounding box might be off by (at least) one pixel for\n     hinted fonts.  See @FT_Size_Metrics for further discussion.\n\n     Note that the bounding box does not vary in OpenType Font Variations\n     and should only be used in relation to the default instance.\n\n   units_per_EM ::\n     The number of font units per EM square for this face.  This is\n     typically 2048 for TrueType fonts, and 1000 for Type~1 fonts.  Only\n     relevant for scalable formats.\n\n   ascender ::\n     The typographic ascender of the face, expressed in font units.  For\n     font formats not having this information, it is set to `bbox.yMax`.\n     Only relevant for scalable formats.\n\n   descender ::\n     The typographic descender of the face, expressed in font units.  For\n     font formats not having this information, it is set to `bbox.yMin`.\n     Note that this field is negative for values below the baseline.\n     Only relevant for scalable formats.\n\n   height ::\n     This value is the vertical distance between two consecutive\n     baselines, expressed in font units.  It is always positive.  Only\n     relevant for scalable formats.\n\n     If you want the global glyph height, use `ascender - descender`.\n\n   max_advance_width ::\n     The maximum advance width, in font units, for all glyphs in this\n     face.  This can be used to make word wrapping computations faster.\n     Only relevant for scalable formats.\n\n   max_advance_height ::\n     The maximum advance height, in font units, for all glyphs in this\n     face.  This is only relevant for vertical layouts, and is set to\n     `height` for fonts that do not provide vertical metrics.  Only\n     relevant for scalable formats.\n\n   underline_position ::\n     The position, in font units, of the underline line for this face.\n     It is the center of the underlining stem.  Only relevant for\n     scalable formats.\n\n   underline_thickness ::\n     The thickness, in font units, of the underline for this face.  Only\n     relevant for scalable formats.\n\n   glyph ::\n     The face's associated glyph slot(s).\n\n   size ::\n     The current active size for this face.\n\n   charmap ::\n     The current active charmap for this face.\n\n @note:\n   Fields may be changed after a call to @FT_Attach_File or\n   @FT_Attach_Stream.\n\n   For OpenType Font Variations, the values of the following fields can\n   change after a call to @FT_Set_Var_Design_Coordinates (and friends) if\n   the font contains an 'MVAR' table: `ascender`, `descender`, `height`,\n   `underline_position`, and `underline_thickness`.\n\n   Especially for TrueType fonts see also the documentation for\n   @FT_Size_Metrics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_FaceRec_ {
    pub num_faces: FT_Long,
    pub face_index: FT_Long,
    pub face_flags: FT_Long,
    pub style_flags: FT_Long,
    pub num_glyphs: FT_Long,
    pub family_name: *mut FT_String,
    pub style_name: *mut FT_String,
    pub num_fixed_sizes: FT_Int,
    pub available_sizes: *mut FT_Bitmap_Size,
    pub num_charmaps: FT_Int,
    pub charmaps: *mut FT_CharMap,
    pub generic: FT_Generic,
    pub bbox: FT_BBox,
    pub units_per_EM: FT_UShort,
    pub ascender: FT_Short,
    pub descender: FT_Short,
    pub height: FT_Short,
    pub max_advance_width: FT_Short,
    pub max_advance_height: FT_Short,
    pub underline_position: FT_Short,
    pub underline_thickness: FT_Short,
    pub glyph: FT_GlyphSlot,
    pub size: FT_Size,
    pub charmap: FT_CharMap,
    pub driver: FT_Driver,
    pub memory: FT_Memory,
    pub stream: FT_Stream,
    pub sizes_list: FT_ListRec,
    pub autohint: FT_Generic,
    pub extensions: *mut ::std::os::raw::c_void,
    pub internal: FT_Face_Internal,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_FaceRec_"][::std::mem::size_of::<FT_FaceRec_>() - 248usize];
    ["Alignment of FT_FaceRec_"][::std::mem::align_of::<FT_FaceRec_>() - 8usize];
    ["Offset of field: FT_FaceRec_::num_faces"]
        [::std::mem::offset_of!(FT_FaceRec_, num_faces) - 0usize];
    ["Offset of field: FT_FaceRec_::face_index"]
        [::std::mem::offset_of!(FT_FaceRec_, face_index) - 8usize];
    ["Offset of field: FT_FaceRec_::face_flags"]
        [::std::mem::offset_of!(FT_FaceRec_, face_flags) - 16usize];
    ["Offset of field: FT_FaceRec_::style_flags"]
        [::std::mem::offset_of!(FT_FaceRec_, style_flags) - 24usize];
    ["Offset of field: FT_FaceRec_::num_glyphs"]
        [::std::mem::offset_of!(FT_FaceRec_, num_glyphs) - 32usize];
    ["Offset of field: FT_FaceRec_::family_name"]
        [::std::mem::offset_of!(FT_FaceRec_, family_name) - 40usize];
    ["Offset of field: FT_FaceRec_::style_name"]
        [::std::mem::offset_of!(FT_FaceRec_, style_name) - 48usize];
    ["Offset of field: FT_FaceRec_::num_fixed_sizes"]
        [::std::mem::offset_of!(FT_FaceRec_, num_fixed_sizes) - 56usize];
    ["Offset of field: FT_FaceRec_::available_sizes"]
        [::std::mem::offset_of!(FT_FaceRec_, available_sizes) - 64usize];
    ["Offset of field: FT_FaceRec_::num_charmaps"]
        [::std::mem::offset_of!(FT_FaceRec_, num_charmaps) - 72usize];
    ["Offset of field: FT_FaceRec_::charmaps"]
        [::std::mem::offset_of!(FT_FaceRec_, charmaps) - 80usize];
    ["Offset of field: FT_FaceRec_::generic"]
        [::std::mem::offset_of!(FT_FaceRec_, generic) - 88usize];
    ["Offset of field: FT_FaceRec_::bbox"][::std::mem::offset_of!(FT_FaceRec_, bbox) - 104usize];
    ["Offset of field: FT_FaceRec_::units_per_EM"]
        [::std::mem::offset_of!(FT_FaceRec_, units_per_EM) - 136usize];
    ["Offset of field: FT_FaceRec_::ascender"]
        [::std::mem::offset_of!(FT_FaceRec_, ascender) - 138usize];
    ["Offset of field: FT_FaceRec_::descender"]
        [::std::mem::offset_of!(FT_FaceRec_, descender) - 140usize];
    ["Offset of field: FT_FaceRec_::height"]
        [::std::mem::offset_of!(FT_FaceRec_, height) - 142usize];
    ["Offset of field: FT_FaceRec_::max_advance_width"]
        [::std::mem::offset_of!(FT_FaceRec_, max_advance_width) - 144usize];
    ["Offset of field: FT_FaceRec_::max_advance_height"]
        [::std::mem::offset_of!(FT_FaceRec_, max_advance_height) - 146usize];
    ["Offset of field: FT_FaceRec_::underline_position"]
        [::std::mem::offset_of!(FT_FaceRec_, underline_position) - 148usize];
    ["Offset of field: FT_FaceRec_::underline_thickness"]
        [::std::mem::offset_of!(FT_FaceRec_, underline_thickness) - 150usize];
    ["Offset of field: FT_FaceRec_::glyph"][::std::mem::offset_of!(FT_FaceRec_, glyph) - 152usize];
    ["Offset of field: FT_FaceRec_::size"][::std::mem::offset_of!(FT_FaceRec_, size) - 160usize];
    ["Offset of field: FT_FaceRec_::charmap"]
        [::std::mem::offset_of!(FT_FaceRec_, charmap) - 168usize];
    ["Offset of field: FT_FaceRec_::driver"]
        [::std::mem::offset_of!(FT_FaceRec_, driver) - 176usize];
    ["Offset of field: FT_FaceRec_::memory"]
        [::std::mem::offset_of!(FT_FaceRec_, memory) - 184usize];
    ["Offset of field: FT_FaceRec_::stream"]
        [::std::mem::offset_of!(FT_FaceRec_, stream) - 192usize];
    ["Offset of field: FT_FaceRec_::sizes_list"]
        [::std::mem::offset_of!(FT_FaceRec_, sizes_list) - 200usize];
    ["Offset of field: FT_FaceRec_::autohint"]
        [::std::mem::offset_of!(FT_FaceRec_, autohint) - 216usize];
    ["Offset of field: FT_FaceRec_::extensions"]
        [::std::mem::offset_of!(FT_FaceRec_, extensions) - 232usize];
    ["Offset of field: FT_FaceRec_::internal"]
        [::std::mem::offset_of!(FT_FaceRec_, internal) - 240usize];
};
#[doc = " @struct:\n   FT_FaceRec\n\n @description:\n   FreeType root face class structure.  A face object models a typeface\n   in a font file.\n\n @fields:\n   num_faces ::\n     The number of faces in the font file.  Some font formats can have\n     multiple faces in a single font file.\n\n   face_index ::\n     This field holds two different values.  Bits 0-15 are the index of\n     the face in the font file (starting with value~0).  They are set\n     to~0 if there is only one face in the font file.\n\n     [Since 2.6.1] Bits 16-30 are relevant to TrueType GX and OpenType\n     Font Variations only, holding the named instance index for the\n     current face index (starting with value~1; value~0 indicates font\n     access without a named instance).  For non-variation fonts, bits\n     16-30 are ignored.  If we have the third named instance of face~4,\n     say, `face_index` is set to 0x00030004.\n\n     Bit 31 is always zero (that is, `face_index` is always a positive\n     value).\n\n     [Since 2.9] Changing the design coordinates with\n     @FT_Set_Var_Design_Coordinates or @FT_Set_Var_Blend_Coordinates does\n     not influence the named instance index value (only\n     @FT_Set_Named_Instance does that).\n\n   face_flags ::\n     A set of bit flags that give important information about the face;\n     see @FT_FACE_FLAG_XXX for the details.\n\n   style_flags ::\n     The lower 16~bits contain a set of bit flags indicating the style of\n     the face; see @FT_STYLE_FLAG_XXX for the details.\n\n     [Since 2.6.1] Bits 16-30 hold the number of named instances\n     available for the current face if we have a TrueType GX or OpenType\n     Font Variation.  Bit 31 is always zero (that is, `style_flags` is\n     always a positive value).  Note that a variation font has always at\n     least one named instance, namely the default instance.\n\n   num_glyphs ::\n     The number of glyphs in the face.  If the face is scalable and has\n     sbits (see `num_fixed_sizes`), it is set to the number of outline\n     glyphs.\n\n     For CID-keyed fonts (not in an SFNT wrapper) this value gives the\n     highest CID used in the font.\n\n   family_name ::\n     The face's family name.  This is an ASCII string, usually in\n     English, that describes the typeface's family (like 'Times New\n     Roman', 'Bodoni', 'Garamond', etc).  This is a least common\n     denominator used to list fonts.  Some formats (TrueType & OpenType)\n     provide localized and Unicode versions of this string.  Applications\n     should use the format-specific interface to access them.  Can be\n     `NULL` (e.g., in fonts embedded in a PDF file).\n\n     In case the font doesn't provide a specific family name entry,\n     FreeType tries to synthesize one, deriving it from other name\n     entries.\n\n   style_name ::\n     The face's style name.  This is an ASCII string, usually in English,\n     that describes the typeface's style (like 'Italic', 'Bold',\n     'Condensed', etc).  Not all font formats provide a style name, so\n     this field is optional, and can be set to `NULL`.  As for\n     `family_name`, some formats provide localized and Unicode versions\n     of this string.  Applications should use the format-specific\n     interface to access them.\n\n   num_fixed_sizes ::\n     The number of bitmap strikes in the face.  Even if the face is\n     scalable, there might still be bitmap strikes, which are called\n     'sbits' in that case.\n\n   available_sizes ::\n     An array of @FT_Bitmap_Size for all bitmap strikes in the face.  It\n     is set to `NULL` if there is no bitmap strike.\n\n     Note that FreeType tries to sanitize the strike data since they are\n     sometimes sloppy or incorrect, but this can easily fail.\n\n   num_charmaps ::\n     The number of charmaps in the face.\n\n   charmaps ::\n     An array of the charmaps of the face.\n\n   generic ::\n     A field reserved for client uses.  See the @FT_Generic type\n     description.\n\n   bbox ::\n     The font bounding box.  Coordinates are expressed in font units (see\n     `units_per_EM`).  The box is large enough to contain any glyph from\n     the font.  Thus, `bbox.yMax` can be seen as the 'maximum ascender',\n     and `bbox.yMin` as the 'minimum descender'.  Only relevant for\n     scalable formats.\n\n     Note that the bounding box might be off by (at least) one pixel for\n     hinted fonts.  See @FT_Size_Metrics for further discussion.\n\n     Note that the bounding box does not vary in OpenType Font Variations\n     and should only be used in relation to the default instance.\n\n   units_per_EM ::\n     The number of font units per EM square for this face.  This is\n     typically 2048 for TrueType fonts, and 1000 for Type~1 fonts.  Only\n     relevant for scalable formats.\n\n   ascender ::\n     The typographic ascender of the face, expressed in font units.  For\n     font formats not having this information, it is set to `bbox.yMax`.\n     Only relevant for scalable formats.\n\n   descender ::\n     The typographic descender of the face, expressed in font units.  For\n     font formats not having this information, it is set to `bbox.yMin`.\n     Note that this field is negative for values below the baseline.\n     Only relevant for scalable formats.\n\n   height ::\n     This value is the vertical distance between two consecutive\n     baselines, expressed in font units.  It is always positive.  Only\n     relevant for scalable formats.\n\n     If you want the global glyph height, use `ascender - descender`.\n\n   max_advance_width ::\n     The maximum advance width, in font units, for all glyphs in this\n     face.  This can be used to make word wrapping computations faster.\n     Only relevant for scalable formats.\n\n   max_advance_height ::\n     The maximum advance height, in font units, for all glyphs in this\n     face.  This is only relevant for vertical layouts, and is set to\n     `height` for fonts that do not provide vertical metrics.  Only\n     relevant for scalable formats.\n\n   underline_position ::\n     The position, in font units, of the underline line for this face.\n     It is the center of the underlining stem.  Only relevant for\n     scalable formats.\n\n   underline_thickness ::\n     The thickness, in font units, of the underline for this face.  Only\n     relevant for scalable formats.\n\n   glyph ::\n     The face's associated glyph slot(s).\n\n   size ::\n     The current active size for this face.\n\n   charmap ::\n     The current active charmap for this face.\n\n @note:\n   Fields may be changed after a call to @FT_Attach_File or\n   @FT_Attach_Stream.\n\n   For OpenType Font Variations, the values of the following fields can\n   change after a call to @FT_Set_Var_Design_Coordinates (and friends) if\n   the font contains an 'MVAR' table: `ascender`, `descender`, `height`,\n   `underline_position`, and `underline_thickness`.\n\n   Especially for TrueType fonts see also the documentation for\n   @FT_Size_Metrics."]
pub type FT_FaceRec = FT_FaceRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Size_InternalRec_ {
    _unused: [u8; 0],
}
#[doc = " @type:\n   FT_Size_Internal\n\n @description:\n   An opaque handle to an `FT_Size_InternalRec` structure, used to model\n   private data of a given @FT_Size object."]
pub type FT_Size_Internal = *mut FT_Size_InternalRec_;
#[doc = " @struct:\n   FT_Size_Metrics\n\n @description:\n   The size metrics structure gives the metrics of a size object.\n\n @fields:\n   x_ppem ::\n     The width of the scaled EM square in pixels, hence the term 'ppem'\n     (pixels per EM).  It is also referred to as 'nominal width'.\n\n   y_ppem ::\n     The height of the scaled EM square in pixels, hence the term 'ppem'\n     (pixels per EM).  It is also referred to as 'nominal height'.\n\n   x_scale ::\n     A 16.16 fractional scaling value to convert horizontal metrics from\n     font units to 26.6 fractional pixels.  Only relevant for scalable\n     font formats.\n\n   y_scale ::\n     A 16.16 fractional scaling value to convert vertical metrics from\n     font units to 26.6 fractional pixels.  Only relevant for scalable\n     font formats.\n\n   ascender ::\n     The ascender in 26.6 fractional pixels, rounded up to an integer\n     value.  See @FT_FaceRec for the details.\n\n   descender ::\n     The descender in 26.6 fractional pixels, rounded down to an integer\n     value.  See @FT_FaceRec for the details.\n\n   height ::\n     The height in 26.6 fractional pixels, rounded to an integer value.\n     See @FT_FaceRec for the details.\n\n   max_advance ::\n     The maximum advance width in 26.6 fractional pixels, rounded to an\n     integer value.  See @FT_FaceRec for the details.\n\n @note:\n   The scaling values, if relevant, are determined first during a size\n   changing operation.  The remaining fields are then set by the driver.\n   For scalable formats, they are usually set to scaled values of the\n   corresponding fields in @FT_FaceRec.  Some values like ascender or\n   descender are rounded for historical reasons; more precise values (for\n   outline fonts) can be derived by scaling the corresponding @FT_FaceRec\n   values manually, with code similar to the following.\n\n   ```\n     scaled_ascender = FT_MulFix( face->ascender,\n                                  size_metrics->y_scale );\n   ```\n\n   Note that due to glyph hinting and the selected rendering mode these\n   values are usually not exact; consequently, they must be treated as\n   unreliable with an error margin of at least one pixel!\n\n   Indeed, the only way to get the exact metrics is to render _all_\n   glyphs.  As this would be a definite performance hit, it is up to\n   client applications to perform such computations.\n\n   The `FT_Size_Metrics` structure is valid for bitmap fonts also.\n\n\n   **TrueType fonts with native bytecode hinting**\n\n   All applications that handle TrueType fonts with native hinting must\n   be aware that TTFs expect different rounding of vertical font\n   dimensions.  The application has to cater for this, especially if it\n   wants to rely on a TTF's vertical data (for example, to properly align\n   box characters vertically).\n\n   Only the application knows _in advance_ that it is going to use native\n   hinting for TTFs!  FreeType, on the other hand, selects the hinting\n   mode not at the time of creating an @FT_Size object but much later,\n   namely while calling @FT_Load_Glyph.\n\n   Here is some pseudo code that illustrates a possible solution.\n\n   ```\n     font_format = FT_Get_Font_Format( face );\n\n     if ( !strcmp( font_format, \"TrueType\" ) &&\n          do_native_bytecode_hinting         )\n     {\n       ascender  = ROUND( FT_MulFix( face->ascender,\n                                     size_metrics->y_scale ) );\n       descender = ROUND( FT_MulFix( face->descender,\n                                     size_metrics->y_scale ) );\n     }\n     else\n     {\n       ascender  = size_metrics->ascender;\n       descender = size_metrics->descender;\n     }\n\n     height      = size_metrics->height;\n     max_advance = size_metrics->max_advance;\n   ```"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Size_Metrics_ {
    pub x_ppem: FT_UShort,
    pub y_ppem: FT_UShort,
    pub x_scale: FT_Fixed,
    pub y_scale: FT_Fixed,
    pub ascender: FT_Pos,
    pub descender: FT_Pos,
    pub height: FT_Pos,
    pub max_advance: FT_Pos,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_Size_Metrics_"][::std::mem::size_of::<FT_Size_Metrics_>() - 56usize];
    ["Alignment of FT_Size_Metrics_"][::std::mem::align_of::<FT_Size_Metrics_>() - 8usize];
    ["Offset of field: FT_Size_Metrics_::x_ppem"]
        [::std::mem::offset_of!(FT_Size_Metrics_, x_ppem) - 0usize];
    ["Offset of field: FT_Size_Metrics_::y_ppem"]
        [::std::mem::offset_of!(FT_Size_Metrics_, y_ppem) - 2usize];
    ["Offset of field: FT_Size_Metrics_::x_scale"]
        [::std::mem::offset_of!(FT_Size_Metrics_, x_scale) - 8usize];
    ["Offset of field: FT_Size_Metrics_::y_scale"]
        [::std::mem::offset_of!(FT_Size_Metrics_, y_scale) - 16usize];
    ["Offset of field: FT_Size_Metrics_::ascender"]
        [::std::mem::offset_of!(FT_Size_Metrics_, ascender) - 24usize];
    ["Offset of field: FT_Size_Metrics_::descender"]
        [::std::mem::offset_of!(FT_Size_Metrics_, descender) - 32usize];
    ["Offset of field: FT_Size_Metrics_::height"]
        [::std::mem::offset_of!(FT_Size_Metrics_, height) - 40usize];
    ["Offset of field: FT_Size_Metrics_::max_advance"]
        [::std::mem::offset_of!(FT_Size_Metrics_, max_advance) - 48usize];
};
#[doc = " @struct:\n   FT_Size_Metrics\n\n @description:\n   The size metrics structure gives the metrics of a size object.\n\n @fields:\n   x_ppem ::\n     The width of the scaled EM square in pixels, hence the term 'ppem'\n     (pixels per EM).  It is also referred to as 'nominal width'.\n\n   y_ppem ::\n     The height of the scaled EM square in pixels, hence the term 'ppem'\n     (pixels per EM).  It is also referred to as 'nominal height'.\n\n   x_scale ::\n     A 16.16 fractional scaling value to convert horizontal metrics from\n     font units to 26.6 fractional pixels.  Only relevant for scalable\n     font formats.\n\n   y_scale ::\n     A 16.16 fractional scaling value to convert vertical metrics from\n     font units to 26.6 fractional pixels.  Only relevant for scalable\n     font formats.\n\n   ascender ::\n     The ascender in 26.6 fractional pixels, rounded up to an integer\n     value.  See @FT_FaceRec for the details.\n\n   descender ::\n     The descender in 26.6 fractional pixels, rounded down to an integer\n     value.  See @FT_FaceRec for the details.\n\n   height ::\n     The height in 26.6 fractional pixels, rounded to an integer value.\n     See @FT_FaceRec for the details.\n\n   max_advance ::\n     The maximum advance width in 26.6 fractional pixels, rounded to an\n     integer value.  See @FT_FaceRec for the details.\n\n @note:\n   The scaling values, if relevant, are determined first during a size\n   changing operation.  The remaining fields are then set by the driver.\n   For scalable formats, they are usually set to scaled values of the\n   corresponding fields in @FT_FaceRec.  Some values like ascender or\n   descender are rounded for historical reasons; more precise values (for\n   outline fonts) can be derived by scaling the corresponding @FT_FaceRec\n   values manually, with code similar to the following.\n\n   ```\n     scaled_ascender = FT_MulFix( face->ascender,\n                                  size_metrics->y_scale );\n   ```\n\n   Note that due to glyph hinting and the selected rendering mode these\n   values are usually not exact; consequently, they must be treated as\n   unreliable with an error margin of at least one pixel!\n\n   Indeed, the only way to get the exact metrics is to render _all_\n   glyphs.  As this would be a definite performance hit, it is up to\n   client applications to perform such computations.\n\n   The `FT_Size_Metrics` structure is valid for bitmap fonts also.\n\n\n   **TrueType fonts with native bytecode hinting**\n\n   All applications that handle TrueType fonts with native hinting must\n   be aware that TTFs expect different rounding of vertical font\n   dimensions.  The application has to cater for this, especially if it\n   wants to rely on a TTF's vertical data (for example, to properly align\n   box characters vertically).\n\n   Only the application knows _in advance_ that it is going to use native\n   hinting for TTFs!  FreeType, on the other hand, selects the hinting\n   mode not at the time of creating an @FT_Size object but much later,\n   namely while calling @FT_Load_Glyph.\n\n   Here is some pseudo code that illustrates a possible solution.\n\n   ```\n     font_format = FT_Get_Font_Format( face );\n\n     if ( !strcmp( font_format, \"TrueType\" ) &&\n          do_native_bytecode_hinting         )\n     {\n       ascender  = ROUND( FT_MulFix( face->ascender,\n                                     size_metrics->y_scale ) );\n       descender = ROUND( FT_MulFix( face->descender,\n                                     size_metrics->y_scale ) );\n     }\n     else\n     {\n       ascender  = size_metrics->ascender;\n       descender = size_metrics->descender;\n     }\n\n     height      = size_metrics->height;\n     max_advance = size_metrics->max_advance;\n   ```"]
pub type FT_Size_Metrics = FT_Size_Metrics_;
#[doc = " @struct:\n   FT_SizeRec\n\n @description:\n   FreeType root size class structure.  A size object models a face\n   object at a given size.\n\n @fields:\n   face ::\n     Handle to the parent face object.\n\n   generic ::\n     A typeless pointer, unused by the FreeType library or any of its\n     drivers.  It can be used by client applications to link their own\n     data to each size object.\n\n   metrics ::\n     Metrics for this size object.  This field is read-only."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_SizeRec_ {
    pub face: FT_Face,
    pub generic: FT_Generic,
    pub metrics: FT_Size_Metrics,
    pub internal: FT_Size_Internal,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_SizeRec_"][::std::mem::size_of::<FT_SizeRec_>() - 88usize];
    ["Alignment of FT_SizeRec_"][::std::mem::align_of::<FT_SizeRec_>() - 8usize];
    ["Offset of field: FT_SizeRec_::face"][::std::mem::offset_of!(FT_SizeRec_, face) - 0usize];
    ["Offset of field: FT_SizeRec_::generic"]
        [::std::mem::offset_of!(FT_SizeRec_, generic) - 8usize];
    ["Offset of field: FT_SizeRec_::metrics"]
        [::std::mem::offset_of!(FT_SizeRec_, metrics) - 24usize];
    ["Offset of field: FT_SizeRec_::internal"]
        [::std::mem::offset_of!(FT_SizeRec_, internal) - 80usize];
};
#[doc = " @struct:\n   FT_SizeRec\n\n @description:\n   FreeType root size class structure.  A size object models a face\n   object at a given size.\n\n @fields:\n   face ::\n     Handle to the parent face object.\n\n   generic ::\n     A typeless pointer, unused by the FreeType library or any of its\n     drivers.  It can be used by client applications to link their own\n     data to each size object.\n\n   metrics ::\n     Metrics for this size object.  This field is read-only."]
pub type FT_SizeRec = FT_SizeRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_SubGlyphRec_ {
    _unused: [u8; 0],
}
#[doc = " @struct:\n   FT_SubGlyph\n\n @description:\n   The subglyph structure is an internal object used to describe\n   subglyphs (for example, in the case of composites).\n\n @note:\n   The subglyph implementation is not part of the high-level API, hence\n   the forward structure declaration.\n\n   You can however retrieve subglyph information with\n   @FT_Get_SubGlyph_Info."]
pub type FT_SubGlyph = *mut FT_SubGlyphRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Slot_InternalRec_ {
    _unused: [u8; 0],
}
#[doc = " @type:\n   FT_Slot_Internal\n\n @description:\n   An opaque handle to an `FT_Slot_InternalRec` structure, used to model\n   private data of a given @FT_GlyphSlot object."]
pub type FT_Slot_Internal = *mut FT_Slot_InternalRec_;
#[doc = " @struct:\n   FT_GlyphSlotRec\n\n @description:\n   FreeType root glyph slot class structure.  A glyph slot is a container\n   where individual glyphs can be loaded, be they in outline or bitmap\n   format.\n\n @fields:\n   library ::\n     A handle to the FreeType library instance this slot belongs to.\n\n   face ::\n     A handle to the parent face object.\n\n   next ::\n     In some cases (like some font tools), several glyph slots per face\n     object can be a good thing.  As this is rare, the glyph slots are\n     listed through a direct, single-linked list using its `next` field.\n\n   glyph_index ::\n     [Since 2.10] The glyph index passed as an argument to @FT_Load_Glyph\n     while initializing the glyph slot.\n\n   generic ::\n     A typeless pointer unused by the FreeType library or any of its\n     drivers.  It can be used by client applications to link their own\n     data to each glyph slot object.\n\n   metrics ::\n     The metrics of the last loaded glyph in the slot.  The returned\n     values depend on the last load flags (see the @FT_Load_Glyph API\n     function) and can be expressed either in 26.6 fractional pixels or\n     font units.\n\n     Note that even when the glyph image is transformed, the metrics are\n     not.\n\n   linearHoriAdvance ::\n     The advance width of the unhinted glyph.  Its value is expressed in\n     16.16 fractional pixels, unless @FT_LOAD_LINEAR_DESIGN is set when\n     loading the glyph.  This field can be important to perform correct\n     WYSIWYG layout.  Only relevant for scalable glyphs.\n\n   linearVertAdvance ::\n     The advance height of the unhinted glyph.  Its value is expressed in\n     16.16 fractional pixels, unless @FT_LOAD_LINEAR_DESIGN is set when\n     loading the glyph.  This field can be important to perform correct\n     WYSIWYG layout.  Only relevant for scalable glyphs.\n\n   advance ::\n     This shorthand is, depending on @FT_LOAD_IGNORE_TRANSFORM, the\n     transformed (hinted) advance width for the glyph, in 26.6 fractional\n     pixel format.  As specified with @FT_LOAD_VERTICAL_LAYOUT, it uses\n     either the `horiAdvance` or the `vertAdvance` value of `metrics`\n     field.\n\n   format ::\n     This field indicates the format of the image contained in the glyph\n     slot.  Typically @FT_GLYPH_FORMAT_BITMAP, @FT_GLYPH_FORMAT_OUTLINE,\n     or @FT_GLYPH_FORMAT_COMPOSITE, but other values are possible.\n\n   bitmap ::\n     This field is used as a bitmap descriptor.  Note that the address\n     and content of the bitmap buffer can change between calls of\n     @FT_Load_Glyph and a few other functions.\n\n   bitmap_left ::\n     The bitmap's left bearing expressed in integer pixels.\n\n   bitmap_top ::\n     The bitmap's top bearing expressed in integer pixels.  This is the\n     distance from the baseline to the top-most glyph scanline, upwards\n     y~coordinates being **positive**.\n\n   outline ::\n     The outline descriptor for the current glyph image if its format is\n     @FT_GLYPH_FORMAT_OUTLINE.  Once a glyph is loaded, `outline` can be\n     transformed, distorted, emboldened, etc.  However, it must not be\n     freed.\n\n     [Since 2.10.1] If @FT_LOAD_NO_SCALE is set, outline coordinates of\n     OpenType Font Variations for a selected instance are internally\n     handled as 26.6 fractional font units but returned as (rounded)\n     integers, as expected.  To get unrounded font units, don't use\n     @FT_LOAD_NO_SCALE but load the glyph with @FT_LOAD_NO_HINTING and\n     scale it, using the font's `units_per_EM` value as the ppem.\n\n   num_subglyphs ::\n     The number of subglyphs in a composite glyph.  This field is only\n     valid for the composite glyph format that should normally only be\n     loaded with the @FT_LOAD_NO_RECURSE flag.\n\n   subglyphs ::\n     An array of subglyph descriptors for composite glyphs.  There are\n     `num_subglyphs` elements in there.  Currently internal to FreeType.\n\n   control_data ::\n     Certain font drivers can also return the control data for a given\n     glyph image (e.g.  TrueType bytecode, Type~1 charstrings, etc.).\n     This field is a pointer to such data; it is currently internal to\n     FreeType.\n\n   control_len ::\n     This is the length in bytes of the control data.  Currently internal\n     to FreeType.\n\n   other ::\n     Reserved.\n\n   lsb_delta ::\n     The difference between hinted and unhinted left side bearing while\n     auto-hinting is active.  Zero otherwise.\n\n   rsb_delta ::\n     The difference between hinted and unhinted right side bearing while\n     auto-hinting is active.  Zero otherwise.\n\n @note:\n   If @FT_Load_Glyph is called with default flags (see @FT_LOAD_DEFAULT)\n   the glyph image is loaded in the glyph slot in its native format\n   (e.g., an outline glyph for TrueType and Type~1 formats).  [Since 2.9]\n   The prospective bitmap metrics are calculated according to\n   @FT_LOAD_TARGET_XXX and other flags even for the outline glyph, even\n   if @FT_LOAD_RENDER is not set.\n\n   This image can later be converted into a bitmap by calling\n   @FT_Render_Glyph.  This function searches the current renderer for the\n   native image's format, then invokes it.\n\n   The renderer is in charge of transforming the native image through the\n   slot's face transformation fields, then converting it into a bitmap\n   that is returned in `slot->bitmap`.\n\n   Note that `slot->bitmap_left` and `slot->bitmap_top` are also used to\n   specify the position of the bitmap relative to the current pen\n   position (e.g., coordinates (0,0) on the baseline).  Of course,\n   `slot->format` is also changed to @FT_GLYPH_FORMAT_BITMAP.\n\n   Here is a small pseudo code fragment that shows how to use `lsb_delta`\n   and `rsb_delta` to do fractional positioning of glyphs:\n\n   ```\n     FT_GlyphSlot  slot     = face->glyph;\n     FT_Pos        origin_x = 0;\n\n\n     for all glyphs do\n       <load glyph with `FT_Load_Glyph'>\n\n       FT_Outline_Translate( slot->outline, origin_x & 63, 0 );\n\n       <save glyph image, or render glyph, or ...>\n\n       <compute kern between current and next glyph\n        and add it to `origin_x'>\n\n       origin_x += slot->advance.x;\n       origin_x += slot->lsb_delta - slot->rsb_delta;\n     endfor\n   ```\n\n   Here is another small pseudo code fragment that shows how to use\n   `lsb_delta` and `rsb_delta` to improve integer positioning of glyphs:\n\n   ```\n     FT_GlyphSlot  slot           = face->glyph;\n     FT_Pos        origin_x       = 0;\n     FT_Pos        prev_rsb_delta = 0;\n\n\n     for all glyphs do\n       <compute kern between current and previous glyph\n        and add it to `origin_x'>\n\n       <load glyph with `FT_Load_Glyph'>\n\n       if ( prev_rsb_delta - slot->lsb_delta >  32 )\n         origin_x -= 64;\n       else if ( prev_rsb_delta - slot->lsb_delta < -31 )\n         origin_x += 64;\n\n       prev_rsb_delta = slot->rsb_delta;\n\n       <save glyph image, or render glyph, or ...>\n\n       origin_x += slot->advance.x;\n     endfor\n   ```\n\n   If you use strong auto-hinting, you **must** apply these delta values!\n   Otherwise you will experience far too large inter-glyph spacing at\n   small rendering sizes in most cases.  Note that it doesn't harm to use\n   the above code for other hinting modes also, since the delta values\n   are zero then."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_GlyphSlotRec_ {
    pub library: FT_Library,
    pub face: FT_Face,
    pub next: FT_GlyphSlot,
    pub glyph_index: FT_UInt,
    pub generic: FT_Generic,
    pub metrics: FT_Glyph_Metrics,
    pub linearHoriAdvance: FT_Fixed,
    pub linearVertAdvance: FT_Fixed,
    pub advance: FT_Vector,
    pub format: FT_Glyph_Format,
    pub bitmap: FT_Bitmap,
    pub bitmap_left: FT_Int,
    pub bitmap_top: FT_Int,
    pub outline: FT_Outline,
    pub num_subglyphs: FT_UInt,
    pub subglyphs: FT_SubGlyph,
    pub control_data: *mut ::std::os::raw::c_void,
    pub control_len: ::std::os::raw::c_long,
    pub lsb_delta: FT_Pos,
    pub rsb_delta: FT_Pos,
    pub other: *mut ::std::os::raw::c_void,
    pub internal: FT_Slot_Internal,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_GlyphSlotRec_"][::std::mem::size_of::<FT_GlyphSlotRec_>() - 304usize];
    ["Alignment of FT_GlyphSlotRec_"][::std::mem::align_of::<FT_GlyphSlotRec_>() - 8usize];
    ["Offset of field: FT_GlyphSlotRec_::library"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, library) - 0usize];
    ["Offset of field: FT_GlyphSlotRec_::face"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, face) - 8usize];
    ["Offset of field: FT_GlyphSlotRec_::next"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, next) - 16usize];
    ["Offset of field: FT_GlyphSlotRec_::glyph_index"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, glyph_index) - 24usize];
    ["Offset of field: FT_GlyphSlotRec_::generic"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, generic) - 32usize];
    ["Offset of field: FT_GlyphSlotRec_::metrics"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, metrics) - 48usize];
    ["Offset of field: FT_GlyphSlotRec_::linearHoriAdvance"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, linearHoriAdvance) - 112usize];
    ["Offset of field: FT_GlyphSlotRec_::linearVertAdvance"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, linearVertAdvance) - 120usize];
    ["Offset of field: FT_GlyphSlotRec_::advance"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, advance) - 128usize];
    ["Offset of field: FT_GlyphSlotRec_::format"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, format) - 144usize];
    ["Offset of field: FT_GlyphSlotRec_::bitmap"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, bitmap) - 152usize];
    ["Offset of field: FT_GlyphSlotRec_::bitmap_left"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, bitmap_left) - 192usize];
    ["Offset of field: FT_GlyphSlotRec_::bitmap_top"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, bitmap_top) - 196usize];
    ["Offset of field: FT_GlyphSlotRec_::outline"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, outline) - 200usize];
    ["Offset of field: FT_GlyphSlotRec_::num_subglyphs"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, num_subglyphs) - 240usize];
    ["Offset of field: FT_GlyphSlotRec_::subglyphs"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, subglyphs) - 248usize];
    ["Offset of field: FT_GlyphSlotRec_::control_data"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, control_data) - 256usize];
    ["Offset of field: FT_GlyphSlotRec_::control_len"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, control_len) - 264usize];
    ["Offset of field: FT_GlyphSlotRec_::lsb_delta"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, lsb_delta) - 272usize];
    ["Offset of field: FT_GlyphSlotRec_::rsb_delta"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, rsb_delta) - 280usize];
    ["Offset of field: FT_GlyphSlotRec_::other"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, other) - 288usize];
    ["Offset of field: FT_GlyphSlotRec_::internal"]
        [::std::mem::offset_of!(FT_GlyphSlotRec_, internal) - 296usize];
};
#[doc = " @struct:\n   FT_GlyphSlotRec\n\n @description:\n   FreeType root glyph slot class structure.  A glyph slot is a container\n   where individual glyphs can be loaded, be they in outline or bitmap\n   format.\n\n @fields:\n   library ::\n     A handle to the FreeType library instance this slot belongs to.\n\n   face ::\n     A handle to the parent face object.\n\n   next ::\n     In some cases (like some font tools), several glyph slots per face\n     object can be a good thing.  As this is rare, the glyph slots are\n     listed through a direct, single-linked list using its `next` field.\n\n   glyph_index ::\n     [Since 2.10] The glyph index passed as an argument to @FT_Load_Glyph\n     while initializing the glyph slot.\n\n   generic ::\n     A typeless pointer unused by the FreeType library or any of its\n     drivers.  It can be used by client applications to link their own\n     data to each glyph slot object.\n\n   metrics ::\n     The metrics of the last loaded glyph in the slot.  The returned\n     values depend on the last load flags (see the @FT_Load_Glyph API\n     function) and can be expressed either in 26.6 fractional pixels or\n     font units.\n\n     Note that even when the glyph image is transformed, the metrics are\n     not.\n\n   linearHoriAdvance ::\n     The advance width of the unhinted glyph.  Its value is expressed in\n     16.16 fractional pixels, unless @FT_LOAD_LINEAR_DESIGN is set when\n     loading the glyph.  This field can be important to perform correct\n     WYSIWYG layout.  Only relevant for scalable glyphs.\n\n   linearVertAdvance ::\n     The advance height of the unhinted glyph.  Its value is expressed in\n     16.16 fractional pixels, unless @FT_LOAD_LINEAR_DESIGN is set when\n     loading the glyph.  This field can be important to perform correct\n     WYSIWYG layout.  Only relevant for scalable glyphs.\n\n   advance ::\n     This shorthand is, depending on @FT_LOAD_IGNORE_TRANSFORM, the\n     transformed (hinted) advance width for the glyph, in 26.6 fractional\n     pixel format.  As specified with @FT_LOAD_VERTICAL_LAYOUT, it uses\n     either the `horiAdvance` or the `vertAdvance` value of `metrics`\n     field.\n\n   format ::\n     This field indicates the format of the image contained in the glyph\n     slot.  Typically @FT_GLYPH_FORMAT_BITMAP, @FT_GLYPH_FORMAT_OUTLINE,\n     or @FT_GLYPH_FORMAT_COMPOSITE, but other values are possible.\n\n   bitmap ::\n     This field is used as a bitmap descriptor.  Note that the address\n     and content of the bitmap buffer can change between calls of\n     @FT_Load_Glyph and a few other functions.\n\n   bitmap_left ::\n     The bitmap's left bearing expressed in integer pixels.\n\n   bitmap_top ::\n     The bitmap's top bearing expressed in integer pixels.  This is the\n     distance from the baseline to the top-most glyph scanline, upwards\n     y~coordinates being **positive**.\n\n   outline ::\n     The outline descriptor for the current glyph image if its format is\n     @FT_GLYPH_FORMAT_OUTLINE.  Once a glyph is loaded, `outline` can be\n     transformed, distorted, emboldened, etc.  However, it must not be\n     freed.\n\n     [Since 2.10.1] If @FT_LOAD_NO_SCALE is set, outline coordinates of\n     OpenType Font Variations for a selected instance are internally\n     handled as 26.6 fractional font units but returned as (rounded)\n     integers, as expected.  To get unrounded font units, don't use\n     @FT_LOAD_NO_SCALE but load the glyph with @FT_LOAD_NO_HINTING and\n     scale it, using the font's `units_per_EM` value as the ppem.\n\n   num_subglyphs ::\n     The number of subglyphs in a composite glyph.  This field is only\n     valid for the composite glyph format that should normally only be\n     loaded with the @FT_LOAD_NO_RECURSE flag.\n\n   subglyphs ::\n     An array of subglyph descriptors for composite glyphs.  There are\n     `num_subglyphs` elements in there.  Currently internal to FreeType.\n\n   control_data ::\n     Certain font drivers can also return the control data for a given\n     glyph image (e.g.  TrueType bytecode, Type~1 charstrings, etc.).\n     This field is a pointer to such data; it is currently internal to\n     FreeType.\n\n   control_len ::\n     This is the length in bytes of the control data.  Currently internal\n     to FreeType.\n\n   other ::\n     Reserved.\n\n   lsb_delta ::\n     The difference between hinted and unhinted left side bearing while\n     auto-hinting is active.  Zero otherwise.\n\n   rsb_delta ::\n     The difference between hinted and unhinted right side bearing while\n     auto-hinting is active.  Zero otherwise.\n\n @note:\n   If @FT_Load_Glyph is called with default flags (see @FT_LOAD_DEFAULT)\n   the glyph image is loaded in the glyph slot in its native format\n   (e.g., an outline glyph for TrueType and Type~1 formats).  [Since 2.9]\n   The prospective bitmap metrics are calculated according to\n   @FT_LOAD_TARGET_XXX and other flags even for the outline glyph, even\n   if @FT_LOAD_RENDER is not set.\n\n   This image can later be converted into a bitmap by calling\n   @FT_Render_Glyph.  This function searches the current renderer for the\n   native image's format, then invokes it.\n\n   The renderer is in charge of transforming the native image through the\n   slot's face transformation fields, then converting it into a bitmap\n   that is returned in `slot->bitmap`.\n\n   Note that `slot->bitmap_left` and `slot->bitmap_top` are also used to\n   specify the position of the bitmap relative to the current pen\n   position (e.g., coordinates (0,0) on the baseline).  Of course,\n   `slot->format` is also changed to @FT_GLYPH_FORMAT_BITMAP.\n\n   Here is a small pseudo code fragment that shows how to use `lsb_delta`\n   and `rsb_delta` to do fractional positioning of glyphs:\n\n   ```\n     FT_GlyphSlot  slot     = face->glyph;\n     FT_Pos        origin_x = 0;\n\n\n     for all glyphs do\n       <load glyph with `FT_Load_Glyph'>\n\n       FT_Outline_Translate( slot->outline, origin_x & 63, 0 );\n\n       <save glyph image, or render glyph, or ...>\n\n       <compute kern between current and next glyph\n        and add it to `origin_x'>\n\n       origin_x += slot->advance.x;\n       origin_x += slot->lsb_delta - slot->rsb_delta;\n     endfor\n   ```\n\n   Here is another small pseudo code fragment that shows how to use\n   `lsb_delta` and `rsb_delta` to improve integer positioning of glyphs:\n\n   ```\n     FT_GlyphSlot  slot           = face->glyph;\n     FT_Pos        origin_x       = 0;\n     FT_Pos        prev_rsb_delta = 0;\n\n\n     for all glyphs do\n       <compute kern between current and previous glyph\n        and add it to `origin_x'>\n\n       <load glyph with `FT_Load_Glyph'>\n\n       if ( prev_rsb_delta - slot->lsb_delta >  32 )\n         origin_x -= 64;\n       else if ( prev_rsb_delta - slot->lsb_delta < -31 )\n         origin_x += 64;\n\n       prev_rsb_delta = slot->rsb_delta;\n\n       <save glyph image, or render glyph, or ...>\n\n       origin_x += slot->advance.x;\n     endfor\n   ```\n\n   If you use strong auto-hinting, you **must** apply these delta values!\n   Otherwise you will experience far too large inter-glyph spacing at\n   small rendering sizes in most cases.  Note that it doesn't harm to use\n   the above code for other hinting modes also, since the delta values\n   are zero then."]
pub type FT_GlyphSlotRec = FT_GlyphSlotRec_;
unsafe extern "C" {
    #[doc = " @function:\n   FT_Init_FreeType\n\n @description:\n   Initialize a new FreeType library object.  The set of modules that are\n   registered by this function is determined at build time.\n\n @output:\n   alibrary ::\n     A handle to a new library object.\n\n @return:\n   FreeType error code.  0~means success.\n\n @note:\n   In case you want to provide your own memory allocating routines, use\n   @FT_New_Library instead, followed by a call to @FT_Add_Default_Modules\n   (or a series of calls to @FT_Add_Module) and\n   @FT_Set_Default_Properties.\n\n   See the documentation of @FT_Library and @FT_Face for multi-threading\n   issues.\n\n   If you need reference-counting (cf. @FT_Reference_Library), use\n   @FT_New_Library and @FT_Done_Library.\n\n   If compilation option `FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES` is\n   set, this function reads the `FREETYPE_PROPERTIES` environment\n   variable to control driver properties.  See section @properties for\n   more."]
    pub fn FT_Init_FreeType(alibrary: *mut FT_Library) -> FT_Error;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Done_FreeType\n\n @description:\n   Destroy a given FreeType library object and all of its children,\n   including resources, drivers, faces, sizes, etc.\n\n @input:\n   library ::\n     A handle to the target library object.\n\n @return:\n   FreeType error code.  0~means success."]
    pub fn FT_Done_FreeType(library: FT_Library) -> FT_Error;
}
#[doc = " @struct:\n   FT_Parameter\n\n @description:\n   A simple structure to pass more or less generic parameters to\n   @FT_Open_Face and @FT_Face_Properties.\n\n @fields:\n   tag ::\n     A four-byte identification tag.\n\n   data ::\n     A pointer to the parameter data.\n\n @note:\n   The ID and function of parameters are driver-specific.  See section\n   @parameter_tags for more information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Parameter_ {
    pub tag: FT_ULong,
    pub data: FT_Pointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_Parameter_"][::std::mem::size_of::<FT_Parameter_>() - 16usize];
    ["Alignment of FT_Parameter_"][::std::mem::align_of::<FT_Parameter_>() - 8usize];
    ["Offset of field: FT_Parameter_::tag"][::std::mem::offset_of!(FT_Parameter_, tag) - 0usize];
    ["Offset of field: FT_Parameter_::data"][::std::mem::offset_of!(FT_Parameter_, data) - 8usize];
};
#[doc = " @struct:\n   FT_Parameter\n\n @description:\n   A simple structure to pass more or less generic parameters to\n   @FT_Open_Face and @FT_Face_Properties.\n\n @fields:\n   tag ::\n     A four-byte identification tag.\n\n   data ::\n     A pointer to the parameter data.\n\n @note:\n   The ID and function of parameters are driver-specific.  See section\n   @parameter_tags for more information."]
pub type FT_Parameter = FT_Parameter_;
#[doc = " @struct:\n   FT_Open_Args\n\n @description:\n   A structure to indicate how to open a new font file or stream.  A\n   pointer to such a structure can be used as a parameter for the\n   functions @FT_Open_Face and @FT_Attach_Stream.\n\n @fields:\n   flags ::\n     A set of bit flags indicating how to use the structure.\n\n   memory_base ::\n     The first byte of the file in memory.\n\n   memory_size ::\n     The size in bytes of the file in memory.\n\n   pathname ::\n     A pointer to an 8-bit file pathname, which must be a C~string (i.e.,\n     no null bytes except at the very end).  The pointer is not owned by\n     FreeType.\n\n   stream ::\n     A handle to a source stream object.\n\n   driver ::\n     This field is exclusively used by @FT_Open_Face; it simply specifies\n     the font driver to use for opening the face.  If set to `NULL`,\n     FreeType tries to load the face with each one of the drivers in its\n     list.\n\n   num_params ::\n     The number of extra parameters.\n\n   params ::\n     Extra parameters passed to the font driver when opening a new face.\n\n @note:\n   The stream type is determined by the contents of `flags`:\n\n   If the @FT_OPEN_MEMORY bit is set, assume that this is a memory file\n   of `memory_size` bytes, located at `memory_address`.  The data are not\n   copied, and the client is responsible for releasing and destroying\n   them _after_ the corresponding call to @FT_Done_Face.\n\n   Otherwise, if the @FT_OPEN_STREAM bit is set, assume that a custom\n   input stream `stream` is used.\n\n   Otherwise, if the @FT_OPEN_PATHNAME bit is set, assume that this is a\n   normal file and use `pathname` to open it.\n\n   If none of the above bits are set or if multiple are set at the same\n   time, the flags are invalid and @FT_Open_Face fails.\n\n   If the @FT_OPEN_DRIVER bit is set, @FT_Open_Face only tries to open\n   the file with the driver whose handler is in `driver`.\n\n   If the @FT_OPEN_PARAMS bit is set, the parameters given by\n   `num_params` and `params` is used.  They are ignored otherwise.\n\n   Ideally, both the `pathname` and `params` fields should be tagged as\n   'const'; this is missing for API backward compatibility.  In other\n   words, applications should treat them as read-only."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Open_Args_ {
    pub flags: FT_UInt,
    pub memory_base: *const FT_Byte,
    pub memory_size: FT_Long,
    pub pathname: *mut FT_String,
    pub stream: FT_Stream,
    pub driver: FT_Module,
    pub num_params: FT_Int,
    pub params: *mut FT_Parameter,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_Open_Args_"][::std::mem::size_of::<FT_Open_Args_>() - 64usize];
    ["Alignment of FT_Open_Args_"][::std::mem::align_of::<FT_Open_Args_>() - 8usize];
    ["Offset of field: FT_Open_Args_::flags"]
        [::std::mem::offset_of!(FT_Open_Args_, flags) - 0usize];
    ["Offset of field: FT_Open_Args_::memory_base"]
        [::std::mem::offset_of!(FT_Open_Args_, memory_base) - 8usize];
    ["Offset of field: FT_Open_Args_::memory_size"]
        [::std::mem::offset_of!(FT_Open_Args_, memory_size) - 16usize];
    ["Offset of field: FT_Open_Args_::pathname"]
        [::std::mem::offset_of!(FT_Open_Args_, pathname) - 24usize];
    ["Offset of field: FT_Open_Args_::stream"]
        [::std::mem::offset_of!(FT_Open_Args_, stream) - 32usize];
    ["Offset of field: FT_Open_Args_::driver"]
        [::std::mem::offset_of!(FT_Open_Args_, driver) - 40usize];
    ["Offset of field: FT_Open_Args_::num_params"]
        [::std::mem::offset_of!(FT_Open_Args_, num_params) - 48usize];
    ["Offset of field: FT_Open_Args_::params"]
        [::std::mem::offset_of!(FT_Open_Args_, params) - 56usize];
};
#[doc = " @struct:\n   FT_Open_Args\n\n @description:\n   A structure to indicate how to open a new font file or stream.  A\n   pointer to such a structure can be used as a parameter for the\n   functions @FT_Open_Face and @FT_Attach_Stream.\n\n @fields:\n   flags ::\n     A set of bit flags indicating how to use the structure.\n\n   memory_base ::\n     The first byte of the file in memory.\n\n   memory_size ::\n     The size in bytes of the file in memory.\n\n   pathname ::\n     A pointer to an 8-bit file pathname, which must be a C~string (i.e.,\n     no null bytes except at the very end).  The pointer is not owned by\n     FreeType.\n\n   stream ::\n     A handle to a source stream object.\n\n   driver ::\n     This field is exclusively used by @FT_Open_Face; it simply specifies\n     the font driver to use for opening the face.  If set to `NULL`,\n     FreeType tries to load the face with each one of the drivers in its\n     list.\n\n   num_params ::\n     The number of extra parameters.\n\n   params ::\n     Extra parameters passed to the font driver when opening a new face.\n\n @note:\n   The stream type is determined by the contents of `flags`:\n\n   If the @FT_OPEN_MEMORY bit is set, assume that this is a memory file\n   of `memory_size` bytes, located at `memory_address`.  The data are not\n   copied, and the client is responsible for releasing and destroying\n   them _after_ the corresponding call to @FT_Done_Face.\n\n   Otherwise, if the @FT_OPEN_STREAM bit is set, assume that a custom\n   input stream `stream` is used.\n\n   Otherwise, if the @FT_OPEN_PATHNAME bit is set, assume that this is a\n   normal file and use `pathname` to open it.\n\n   If none of the above bits are set or if multiple are set at the same\n   time, the flags are invalid and @FT_Open_Face fails.\n\n   If the @FT_OPEN_DRIVER bit is set, @FT_Open_Face only tries to open\n   the file with the driver whose handler is in `driver`.\n\n   If the @FT_OPEN_PARAMS bit is set, the parameters given by\n   `num_params` and `params` is used.  They are ignored otherwise.\n\n   Ideally, both the `pathname` and `params` fields should be tagged as\n   'const'; this is missing for API backward compatibility.  In other\n   words, applications should treat them as read-only."]
pub type FT_Open_Args = FT_Open_Args_;
unsafe extern "C" {
    #[doc = " @function:\n   FT_New_Face\n\n @description:\n   Call @FT_Open_Face to open a font by its pathname.\n\n @inout:\n   library ::\n     A handle to the library resource.\n\n @input:\n   pathname ::\n     A path to the font file.\n\n   face_index ::\n     See @FT_Open_Face for a detailed description of this parameter.\n\n @output:\n   aface ::\n     A handle to a new face object.  If `face_index` is greater than or\n     equal to zero, it must be non-`NULL`.\n\n @return:\n   FreeType error code.  0~means success.\n\n @note:\n   The `pathname` string should be recognizable as such by a standard\n   `fopen` call on your system; in particular, this means that `pathname`\n   must not contain null bytes.  If that is not sufficient to address all\n   file name possibilities (for example, to handle wide character file\n   names on Windows in UTF-16 encoding) you might use @FT_Open_Face to\n   pass a memory array or a stream object instead.\n\n   Use @FT_Done_Face to destroy the created @FT_Face object (along with\n   its slot and sizes)."]
    pub fn FT_New_Face(
        library: FT_Library,
        filepathname: *const ::std::os::raw::c_char,
        face_index: FT_Long,
        aface: *mut FT_Face,
    ) -> FT_Error;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_New_Memory_Face\n\n @description:\n   Call @FT_Open_Face to open a font that has been loaded into memory.\n\n @inout:\n   library ::\n     A handle to the library resource.\n\n @input:\n   file_base ::\n     A pointer to the beginning of the font data.\n\n   file_size ::\n     The size of the memory chunk used by the font data.\n\n   face_index ::\n     See @FT_Open_Face for a detailed description of this parameter.\n\n @output:\n   aface ::\n     A handle to a new face object.  If `face_index` is greater than or\n     equal to zero, it must be non-`NULL`.\n\n @return:\n   FreeType error code.  0~means success.\n\n @note:\n   You must not deallocate the memory before calling @FT_Done_Face."]
    pub fn FT_New_Memory_Face(
        library: FT_Library,
        file_base: *const FT_Byte,
        file_size: FT_Long,
        face_index: FT_Long,
        aface: *mut FT_Face,
    ) -> FT_Error;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Open_Face\n\n @description:\n   Create a face object from a given resource described by @FT_Open_Args.\n\n @inout:\n   library ::\n     A handle to the library resource.\n\n @input:\n   args ::\n     A pointer to an `FT_Open_Args` structure that must be filled by the\n     caller.\n\n   face_index ::\n     This field holds two different values.  Bits 0-15 are the index of\n     the face in the font file (starting with value~0).  Set it to~0 if\n     there is only one face in the font file.\n\n     [Since 2.6.1] Bits 16-30 are relevant to TrueType GX and OpenType\n     Font Variations only, specifying the named instance index for the\n     current face index (starting with value~1; value~0 makes FreeType\n     ignore named instances).  For non-variation fonts, bits 16-30 are\n     ignored.  Assuming that you want to access the third named instance\n     in face~4, `face_index` should be set to 0x00030004.  If you want\n     to access face~4 without variation handling, simply set\n     `face_index` to value~4.\n\n     `FT_Open_Face` and its siblings can be used to quickly check whether\n     the font format of a given font resource is supported by FreeType.\n     In general, if the `face_index` argument is negative, the function's\n     return value is~0 if the font format is recognized, or non-zero\n     otherwise.  The function allocates a more or less empty face handle\n     in `*aface` (if `aface` isn't `NULL`); the only two useful fields in\n     this special case are `face->num_faces` and `face->style_flags`.\n     For any negative value of `face_index`, `face->num_faces` gives the\n     number of faces within the font file.  For the negative value\n     '-(N+1)' (with 'N' a non-negative 16-bit value), bits 16-30 in\n     `face->style_flags` give the number of named instances in face 'N'\n     if we have a variation font (or zero otherwise).  After examination,\n     the returned @FT_Face structure should be deallocated with a call to\n     @FT_Done_Face.\n\n @output:\n   aface ::\n     A handle to a new face object.  If `face_index` is greater than or\n     equal to zero, it must be non-`NULL`.\n\n @return:\n   FreeType error code.  0~means success.\n\n @note:\n   Unlike FreeType 1.x, this function automatically creates a glyph slot\n   for the face object that can be accessed directly through\n   `face->glyph`.\n\n   Each new face object created with this function also owns a default\n   @FT_Size object, accessible as `face->size`.\n\n   One @FT_Library instance can have multiple face objects, that is,\n   @FT_Open_Face and its siblings can be called multiple times using the\n   same `library` argument.\n\n   See the discussion of reference counters in the description of\n   @FT_Reference_Face.\n\n   If `FT_OPEN_STREAM` is set in `args->flags`, the stream in\n   `args->stream` is automatically closed before this function returns\n   any error (including `FT_Err_Invalid_Argument`).\n\n @example:\n   To loop over all faces, use code similar to the following snippet\n   (omitting the error handling).\n\n   ```\n     ...\n     FT_Face  face;\n     FT_Long  i, num_faces;\n\n\n     error = FT_Open_Face( library, args, -1, &face );\n     if ( error ) { ... }\n\n     num_faces = face->num_faces;\n     FT_Done_Face( face );\n\n     for ( i = 0; i < num_faces; i++ )\n     {\n       ...\n       error = FT_Open_Face( library, args, i, &face );\n       ...\n       FT_Done_Face( face );\n       ...\n     }\n   ```\n\n   To loop over all valid values for `face_index`, use something similar\n   to the following snippet, again without error handling.  The code\n   accesses all faces immediately (thus only a single call of\n   `FT_Open_Face` within the do-loop), with and without named instances.\n\n   ```\n     ...\n     FT_Face  face;\n\n     FT_Long  num_faces     = 0;\n     FT_Long  num_instances = 0;\n\n     FT_Long  face_idx     = 0;\n     FT_Long  instance_idx = 0;\n\n\n     do\n     {\n       FT_Long  id = ( instance_idx << 16 ) + face_idx;\n\n\n       error = FT_Open_Face( library, args, id, &face );\n       if ( error ) { ... }\n\n       num_faces     = face->num_faces;\n       num_instances = face->style_flags >> 16;\n\n       ...\n\n       FT_Done_Face( face );\n\n       if ( instance_idx < num_instances )\n         instance_idx++;\n       else\n       {\n         face_idx++;\n         instance_idx = 0;\n       }\n\n     } while ( face_idx < num_faces )\n   ```"]
    pub fn FT_Open_Face(
        library: FT_Library,
        args: *const FT_Open_Args,
        face_index: FT_Long,
        aface: *mut FT_Face,
    ) -> FT_Error;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Attach_File\n\n @description:\n   Call @FT_Attach_Stream to attach a file.\n\n @inout:\n   face ::\n     The target face object.\n\n @input:\n   filepathname ::\n     The pathname.\n\n @return:\n   FreeType error code.  0~means success."]
    pub fn FT_Attach_File(face: FT_Face, filepathname: *const ::std::os::raw::c_char) -> FT_Error;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Attach_Stream\n\n @description:\n   'Attach' data to a face object.  Normally, this is used to read\n   additional information for the face object.  For example, you can\n   attach an AFM file that comes with a Type~1 font to get the kerning\n   values and other metrics.\n\n @inout:\n   face ::\n     The target face object.\n\n @input:\n   parameters ::\n     A pointer to @FT_Open_Args that must be filled by the caller.\n\n @return:\n   FreeType error code.  0~means success.\n\n @note:\n   The meaning of the 'attach' (i.e., what really happens when the new\n   file is read) is not fixed by FreeType itself.  It really depends on\n   the font format (and thus the font driver).\n\n   Client applications are expected to know what they are doing when\n   invoking this function.  Most drivers simply do not implement file or\n   stream attachments."]
    pub fn FT_Attach_Stream(face: FT_Face, parameters: *const FT_Open_Args) -> FT_Error;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Reference_Face\n\n @description:\n   A counter gets initialized to~1 at the time an @FT_Face structure is\n   created.  This function increments the counter.  @FT_Done_Face then\n   only destroys a face if the counter is~1, otherwise it simply\n   decrements the counter.\n\n   This function helps in managing life-cycles of structures that\n   reference @FT_Face objects.\n\n @input:\n   face ::\n     A handle to a target face object.\n\n @return:\n   FreeType error code.  0~means success.\n\n @since:\n   2.4.2\n"]
    pub fn FT_Reference_Face(face: FT_Face) -> FT_Error;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Done_Face\n\n @description:\n   Discard a given face object, as well as all of its child slots and\n   sizes.\n\n @input:\n   face ::\n     A handle to a target face object.\n\n @return:\n   FreeType error code.  0~means success.\n\n @note:\n   See the discussion of reference counters in the description of\n   @FT_Reference_Face."]
    pub fn FT_Done_Face(face: FT_Face) -> FT_Error;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Select_Size\n\n @description:\n   Select a bitmap strike.  To be more precise, this function sets the\n   scaling factors of the active @FT_Size object in a face so that\n   bitmaps from this particular strike are taken by @FT_Load_Glyph and\n   friends.\n\n @inout:\n   face ::\n     A handle to a target face object.\n\n @input:\n   strike_index ::\n     The index of the bitmap strike in the `available_sizes` field of\n     @FT_FaceRec structure.\n\n @return:\n   FreeType error code.  0~means success.\n\n @note:\n   For bitmaps embedded in outline fonts it is common that only a subset\n   of the available glyphs at a given ppem value is available.  FreeType\n   silently uses outlines if there is no bitmap for a given glyph index.\n\n   For TrueType GX and OpenType Font Variations, a bitmap strike makes\n   sense only if the default instance is active (that is, no glyph\n   variation takes place); otherwise, FreeType simply ignores bitmap\n   strikes.  The same is true for all named instances that are different\n   from the default instance.\n\n   Don't use this function if you are using the FreeType cache API."]
    pub fn FT_Select_Size(face: FT_Face, strike_index: FT_Int) -> FT_Error;
}
pub const FT_Size_Request_Type__FT_SIZE_REQUEST_TYPE_NOMINAL: FT_Size_Request_Type_ = 0;
pub const FT_Size_Request_Type__FT_SIZE_REQUEST_TYPE_REAL_DIM: FT_Size_Request_Type_ = 1;
pub const FT_Size_Request_Type__FT_SIZE_REQUEST_TYPE_BBOX: FT_Size_Request_Type_ = 2;
pub const FT_Size_Request_Type__FT_SIZE_REQUEST_TYPE_CELL: FT_Size_Request_Type_ = 3;
pub const FT_Size_Request_Type__FT_SIZE_REQUEST_TYPE_SCALES: FT_Size_Request_Type_ = 4;
pub const FT_Size_Request_Type__FT_SIZE_REQUEST_TYPE_MAX: FT_Size_Request_Type_ = 5;
#[doc = " @enum:\n   FT_Size_Request_Type\n\n @description:\n   An enumeration type that lists the supported size request types, i.e.,\n   what input size (in font units) maps to the requested output size (in\n   pixels, as computed from the arguments of @FT_Size_Request).\n\n @values:\n   FT_SIZE_REQUEST_TYPE_NOMINAL ::\n     The nominal size.  The `units_per_EM` field of @FT_FaceRec is used\n     to determine both scaling values.\n\n     This is the standard scaling found in most applications.  In\n     particular, use this size request type for TrueType fonts if they\n     provide optical scaling or something similar.  Note, however, that\n     `units_per_EM` is a rather abstract value which bears no relation to\n     the actual size of the glyphs in a font.\n\n   FT_SIZE_REQUEST_TYPE_REAL_DIM ::\n     The real dimension.  The sum of the `ascender` and (minus of) the\n     `descender` fields of @FT_FaceRec is used to determine both scaling\n     values.\n\n   FT_SIZE_REQUEST_TYPE_BBOX ::\n     The font bounding box.  The width and height of the `bbox` field of\n     @FT_FaceRec are used to determine the horizontal and vertical\n     scaling value, respectively.\n\n   FT_SIZE_REQUEST_TYPE_CELL ::\n     The `max_advance_width` field of @FT_FaceRec is used to determine\n     the horizontal scaling value; the vertical scaling value is\n     determined the same way as @FT_SIZE_REQUEST_TYPE_REAL_DIM does.\n     Finally, both scaling values are set to the smaller one.  This type\n     is useful if you want to specify the font size for, say, a window of\n     a given dimension and 80x24 cells.\n\n   FT_SIZE_REQUEST_TYPE_SCALES ::\n     Specify the scaling values directly.\n\n @note:\n   The above descriptions only apply to scalable formats.  For bitmap\n   formats, the behaviour is up to the driver.\n\n   See the note section of @FT_Size_Metrics if you wonder how size\n   requesting relates to scaling values."]
pub type FT_Size_Request_Type_ = ::std::os::raw::c_uint;
#[doc = " @enum:\n   FT_Size_Request_Type\n\n @description:\n   An enumeration type that lists the supported size request types, i.e.,\n   what input size (in font units) maps to the requested output size (in\n   pixels, as computed from the arguments of @FT_Size_Request).\n\n @values:\n   FT_SIZE_REQUEST_TYPE_NOMINAL ::\n     The nominal size.  The `units_per_EM` field of @FT_FaceRec is used\n     to determine both scaling values.\n\n     This is the standard scaling found in most applications.  In\n     particular, use this size request type for TrueType fonts if they\n     provide optical scaling or something similar.  Note, however, that\n     `units_per_EM` is a rather abstract value which bears no relation to\n     the actual size of the glyphs in a font.\n\n   FT_SIZE_REQUEST_TYPE_REAL_DIM ::\n     The real dimension.  The sum of the `ascender` and (minus of) the\n     `descender` fields of @FT_FaceRec is used to determine both scaling\n     values.\n\n   FT_SIZE_REQUEST_TYPE_BBOX ::\n     The font bounding box.  The width and height of the `bbox` field of\n     @FT_FaceRec are used to determine the horizontal and vertical\n     scaling value, respectively.\n\n   FT_SIZE_REQUEST_TYPE_CELL ::\n     The `max_advance_width` field of @FT_FaceRec is used to determine\n     the horizontal scaling value; the vertical scaling value is\n     determined the same way as @FT_SIZE_REQUEST_TYPE_REAL_DIM does.\n     Finally, both scaling values are set to the smaller one.  This type\n     is useful if you want to specify the font size for, say, a window of\n     a given dimension and 80x24 cells.\n\n   FT_SIZE_REQUEST_TYPE_SCALES ::\n     Specify the scaling values directly.\n\n @note:\n   The above descriptions only apply to scalable formats.  For bitmap\n   formats, the behaviour is up to the driver.\n\n   See the note section of @FT_Size_Metrics if you wonder how size\n   requesting relates to scaling values."]
pub use self::FT_Size_Request_Type_ as FT_Size_Request_Type;
#[doc = " @struct:\n   FT_Size_RequestRec\n\n @description:\n   A structure to model a size request.\n\n @fields:\n   type ::\n     See @FT_Size_Request_Type.\n\n   width ::\n     The desired width, given as a 26.6 fractional point value (with 72pt\n     = 1in).\n\n   height ::\n     The desired height, given as a 26.6 fractional point value (with\n     72pt = 1in).\n\n   horiResolution ::\n     The horizontal resolution (dpi, i.e., pixels per inch).  If set to\n     zero, `width` is treated as a 26.6 fractional **pixel** value, which\n     gets internally rounded to an integer.\n\n   vertResolution ::\n     The vertical resolution (dpi, i.e., pixels per inch).  If set to\n     zero, `height` is treated as a 26.6 fractional **pixel** value,\n     which gets internally rounded to an integer.\n\n @note:\n   If `width` is zero, the horizontal scaling value is set equal to the\n   vertical scaling value, and vice versa.\n\n   If `type` is `FT_SIZE_REQUEST_TYPE_SCALES`, `width` and `height` are\n   interpreted directly as 16.16 fractional scaling values, without any\n   further modification, and both `horiResolution` and `vertResolution`\n   are ignored."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Size_RequestRec_ {
    pub type_: FT_Size_Request_Type,
    pub width: FT_Long,
    pub height: FT_Long,
    pub horiResolution: FT_UInt,
    pub vertResolution: FT_UInt,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_Size_RequestRec_"][::std::mem::size_of::<FT_Size_RequestRec_>() - 32usize];
    ["Alignment of FT_Size_RequestRec_"][::std::mem::align_of::<FT_Size_RequestRec_>() - 8usize];
    ["Offset of field: FT_Size_RequestRec_::type_"]
        [::std::mem::offset_of!(FT_Size_RequestRec_, type_) - 0usize];
    ["Offset of field: FT_Size_RequestRec_::width"]
        [::std::mem::offset_of!(FT_Size_RequestRec_, width) - 8usize];
    ["Offset of field: FT_Size_RequestRec_::height"]
        [::std::mem::offset_of!(FT_Size_RequestRec_, height) - 16usize];
    ["Offset of field: FT_Size_RequestRec_::horiResolution"]
        [::std::mem::offset_of!(FT_Size_RequestRec_, horiResolution) - 24usize];
    ["Offset of field: FT_Size_RequestRec_::vertResolution"]
        [::std::mem::offset_of!(FT_Size_RequestRec_, vertResolution) - 28usize];
};
#[doc = " @struct:\n   FT_Size_RequestRec\n\n @description:\n   A structure to model a size request.\n\n @fields:\n   type ::\n     See @FT_Size_Request_Type.\n\n   width ::\n     The desired width, given as a 26.6 fractional point value (with 72pt\n     = 1in).\n\n   height ::\n     The desired height, given as a 26.6 fractional point value (with\n     72pt = 1in).\n\n   horiResolution ::\n     The horizontal resolution (dpi, i.e., pixels per inch).  If set to\n     zero, `width` is treated as a 26.6 fractional **pixel** value, which\n     gets internally rounded to an integer.\n\n   vertResolution ::\n     The vertical resolution (dpi, i.e., pixels per inch).  If set to\n     zero, `height` is treated as a 26.6 fractional **pixel** value,\n     which gets internally rounded to an integer.\n\n @note:\n   If `width` is zero, the horizontal scaling value is set equal to the\n   vertical scaling value, and vice versa.\n\n   If `type` is `FT_SIZE_REQUEST_TYPE_SCALES`, `width` and `height` are\n   interpreted directly as 16.16 fractional scaling values, without any\n   further modification, and both `horiResolution` and `vertResolution`\n   are ignored."]
pub type FT_Size_RequestRec = FT_Size_RequestRec_;
#[doc = " @struct:\n   FT_Size_Request\n\n @description:\n   A handle to a size request structure."]
pub type FT_Size_Request = *mut FT_Size_RequestRec_;
unsafe extern "C" {
    #[doc = " @function:\n   FT_Request_Size\n\n @description:\n   Resize the scale of the active @FT_Size object in a face.\n\n @inout:\n   face ::\n     A handle to a target face object.\n\n @input:\n   req ::\n     A pointer to a @FT_Size_RequestRec.\n\n @return:\n   FreeType error code.  0~means success.\n\n @note:\n   Although drivers may select the bitmap strike matching the request,\n   you should not rely on this if you intend to select a particular\n   bitmap strike.  Use @FT_Select_Size instead in that case.\n\n   The relation between the requested size and the resulting glyph size\n   is dependent entirely on how the size is defined in the source face.\n   The font designer chooses the final size of each glyph relative to\n   this size.  For more information refer to\n   'https://freetype.org/freetype2/docs/glyphs/glyphs-2.html'.\n\n   Contrary to @FT_Set_Char_Size, this function doesn't have special code\n   to normalize zero-valued widths, heights, or resolutions, which are\n   treated as @FT_LOAD_NO_SCALE.\n\n   Don't use this function if you are using the FreeType cache API."]
    pub fn FT_Request_Size(face: FT_Face, req: FT_Size_Request) -> FT_Error;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Set_Char_Size\n\n @description:\n   Call @FT_Request_Size to request the nominal size (in points).\n\n @inout:\n   face ::\n     A handle to a target face object.\n\n @input:\n   char_width ::\n     The nominal width, in 26.6 fractional points.\n\n   char_height ::\n     The nominal height, in 26.6 fractional points.\n\n   horz_resolution ::\n     The horizontal resolution in dpi.\n\n   vert_resolution ::\n     The vertical resolution in dpi.\n\n @return:\n   FreeType error code.  0~means success.\n\n @note:\n   While this function allows fractional points as input values, the\n   resulting ppem value for the given resolution is always rounded to the\n   nearest integer.\n\n   If either the character width or height is zero, it is set equal to\n   the other value.\n\n   If either the horizontal or vertical resolution is zero, it is set\n   equal to the other value.\n\n   A character width or height smaller than 1pt is set to 1pt; if both\n   resolution values are zero, they are set to 72dpi.\n\n   Don't use this function if you are using the FreeType cache API."]
    pub fn FT_Set_Char_Size(
        face: FT_Face,
        char_width: FT_F26Dot6,
        char_height: FT_F26Dot6,
        horz_resolution: FT_UInt,
        vert_resolution: FT_UInt,
    ) -> FT_Error;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Set_Pixel_Sizes\n\n @description:\n   Call @FT_Request_Size to request the nominal size (in pixels).\n\n @inout:\n   face ::\n     A handle to the target face object.\n\n @input:\n   pixel_width ::\n     The nominal width, in pixels.\n\n   pixel_height ::\n     The nominal height, in pixels.\n\n @return:\n   FreeType error code.  0~means success.\n\n @note:\n   You should not rely on the resulting glyphs matching or being\n   constrained to this pixel size.  Refer to @FT_Request_Size to\n   understand how requested sizes relate to actual sizes.\n\n   Don't use this function if you are using the FreeType cache API."]
    pub fn FT_Set_Pixel_Sizes(
        face: FT_Face,
        pixel_width: FT_UInt,
        pixel_height: FT_UInt,
    ) -> FT_Error;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Load_Glyph\n\n @description:\n   Load a glyph into the glyph slot of a face object.\n\n @inout:\n   face ::\n     A handle to the target face object where the glyph is loaded.\n\n @input:\n   glyph_index ::\n     The index of the glyph in the font file.  For CID-keyed fonts\n     (either in PS or in CFF format) this argument specifies the CID\n     value.\n\n   load_flags ::\n     A flag indicating what to load for this glyph.  The @FT_LOAD_XXX\n     flags can be used to control the glyph loading process (e.g.,\n     whether the outline should be scaled, whether to load bitmaps or\n     not, whether to hint the outline, etc).\n\n @return:\n   FreeType error code.  0~means success.\n\n @note:\n   For proper scaling and hinting, the active @FT_Size object owned by\n   the face has to be meaningfully initialized by calling\n   @FT_Set_Char_Size before this function, for example.  The loaded\n   glyph may be transformed.  See @FT_Set_Transform for the details.\n\n   For subsetted CID-keyed fonts, `FT_Err_Invalid_Argument` is returned\n   for invalid CID values (that is, for CID values that don't have a\n   corresponding glyph in the font).  See the discussion of the\n   @FT_FACE_FLAG_CID_KEYED flag for more details.\n\n   If you receive `FT_Err_Glyph_Too_Big`, try getting the glyph outline\n   at EM size, then scale it manually and fill it as a graphics\n   operation."]
    pub fn FT_Load_Glyph(face: FT_Face, glyph_index: FT_UInt, load_flags: FT_Int32) -> FT_Error;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Load_Char\n\n @description:\n   Load a glyph into the glyph slot of a face object, accessed by its\n   character code.\n\n @inout:\n   face ::\n     A handle to a target face object where the glyph is loaded.\n\n @input:\n   char_code ::\n     The glyph's character code, according to the current charmap used in\n     the face.\n\n   load_flags ::\n     A flag indicating what to load for this glyph.  The @FT_LOAD_XXX\n     constants can be used to control the glyph loading process (e.g.,\n     whether the outline should be scaled, whether to load bitmaps or\n     not, whether to hint the outline, etc).\n\n @return:\n   FreeType error code.  0~means success.\n\n @note:\n   This function simply calls @FT_Get_Char_Index and @FT_Load_Glyph.\n\n   Many fonts contain glyphs that can't be loaded by this function since\n   its glyph indices are not listed in any of the font's charmaps.\n\n   If no active cmap is set up (i.e., `face->charmap` is zero), the call\n   to @FT_Get_Char_Index is omitted, and the function behaves identically\n   to @FT_Load_Glyph."]
    pub fn FT_Load_Char(face: FT_Face, char_code: FT_ULong, load_flags: FT_Int32) -> FT_Error;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Set_Transform\n\n @description:\n   Set the transformation that is applied to glyph images when they are\n   loaded into a glyph slot through @FT_Load_Glyph.\n\n @inout:\n   face ::\n     A handle to the source face object.\n\n @input:\n   matrix ::\n     A pointer to the transformation's 2x2 matrix.  Use `NULL` for the\n     identity matrix.\n   delta ::\n     A pointer to the translation vector.  Use `NULL` for the null\n     vector.\n\n @note:\n   This function is provided as a convenience, but keep in mind that\n   @FT_Matrix coefficients are only 16.16 fixed-point values, which can\n   limit the accuracy of the results.  Using floating-point computations\n   to perform the transform directly in client code instead will always\n   yield better numbers.\n\n   The transformation is only applied to scalable image formats after the\n   glyph has been loaded.  It means that hinting is unaltered by the\n   transformation and is performed on the character size given in the\n   last call to @FT_Set_Char_Size or @FT_Set_Pixel_Sizes.\n\n   Note that this also transforms the `face.glyph.advance` field, but\n   **not** the values in `face.glyph.metrics`."]
    pub fn FT_Set_Transform(face: FT_Face, matrix: *mut FT_Matrix, delta: *mut FT_Vector);
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Get_Transform\n\n @description:\n   Return the transformation that is applied to glyph images when they\n   are loaded into a glyph slot through @FT_Load_Glyph.  See\n   @FT_Set_Transform for more details.\n\n @input:\n   face ::\n     A handle to the source face object.\n\n @output:\n   matrix ::\n     A pointer to a transformation's 2x2 matrix.  Set this to NULL if you\n     are not interested in the value.\n\n   delta ::\n     A pointer to a translation vector.  Set this to NULL if you are not\n     interested in the value.\n\n @since:\n   2.11\n"]
    pub fn FT_Get_Transform(face: FT_Face, matrix: *mut FT_Matrix, delta: *mut FT_Vector);
}
pub const FT_Render_Mode__FT_RENDER_MODE_NORMAL: FT_Render_Mode_ = 0;
pub const FT_Render_Mode__FT_RENDER_MODE_LIGHT: FT_Render_Mode_ = 1;
pub const FT_Render_Mode__FT_RENDER_MODE_MONO: FT_Render_Mode_ = 2;
pub const FT_Render_Mode__FT_RENDER_MODE_LCD: FT_Render_Mode_ = 3;
pub const FT_Render_Mode__FT_RENDER_MODE_LCD_V: FT_Render_Mode_ = 4;
pub const FT_Render_Mode__FT_RENDER_MODE_SDF: FT_Render_Mode_ = 5;
pub const FT_Render_Mode__FT_RENDER_MODE_MAX: FT_Render_Mode_ = 6;
#[doc = " @enum:\n   FT_Render_Mode\n\n @description:\n   Render modes supported by FreeType~2.  Each mode corresponds to a\n   specific type of scanline conversion performed on the outline.\n\n   For bitmap fonts and embedded bitmaps the `bitmap->pixel_mode` field\n   in the @FT_GlyphSlotRec structure gives the format of the returned\n   bitmap.\n\n   All modes except @FT_RENDER_MODE_MONO use 256 levels of opacity,\n   indicating pixel coverage.  Use linear alpha blending and gamma\n   correction to correctly render non-monochrome glyph bitmaps onto a\n   surface; see @FT_Render_Glyph.\n\n   The @FT_RENDER_MODE_SDF is a special render mode that uses up to 256\n   distance values, indicating the signed distance from the grid position\n   to the nearest outline.\n\n @values:\n   FT_RENDER_MODE_NORMAL ::\n     Default render mode; it corresponds to 8-bit anti-aliased bitmaps.\n\n   FT_RENDER_MODE_LIGHT ::\n     This is equivalent to @FT_RENDER_MODE_NORMAL.  It is only defined as\n     a separate value because render modes are also used indirectly to\n     define hinting algorithm selectors.  See @FT_LOAD_TARGET_XXX for\n     details.\n\n   FT_RENDER_MODE_MONO ::\n     This mode corresponds to 1-bit bitmaps (with 2~levels of opacity).\n\n   FT_RENDER_MODE_LCD ::\n     This mode corresponds to horizontal RGB and BGR subpixel displays\n     like LCD screens.  It produces 8-bit bitmaps that are 3~times the\n     width of the original glyph outline in pixels, and which use the\n     @FT_PIXEL_MODE_LCD mode.\n\n   FT_RENDER_MODE_LCD_V ::\n     This mode corresponds to vertical RGB and BGR subpixel displays\n     (like PDA screens, rotated LCD displays, etc.).  It produces 8-bit\n     bitmaps that are 3~times the height of the original glyph outline in\n     pixels and use the @FT_PIXEL_MODE_LCD_V mode.\n\n   FT_RENDER_MODE_SDF ::\n     The positive (unsigned) 8-bit bitmap values can be converted to the\n     single-channel signed distance field (SDF) by subtracting 128, with\n     the positive and negative results corresponding to the inside and\n     the outside of a glyph contour, respectively.  The distance units are\n     arbitrarily determined by an adjustable @spread property.\n\n @note:\n   The selected render mode only affects scalable vector glyphs of a font.\n   Embedded bitmaps often have a different pixel mode like\n   @FT_PIXEL_MODE_MONO.  You can use @FT_Bitmap_Convert to transform them\n   into 8-bit pixmaps.\n"]
pub type FT_Render_Mode_ = ::std::os::raw::c_uint;
#[doc = " @enum:\n   FT_Render_Mode\n\n @description:\n   Render modes supported by FreeType~2.  Each mode corresponds to a\n   specific type of scanline conversion performed on the outline.\n\n   For bitmap fonts and embedded bitmaps the `bitmap->pixel_mode` field\n   in the @FT_GlyphSlotRec structure gives the format of the returned\n   bitmap.\n\n   All modes except @FT_RENDER_MODE_MONO use 256 levels of opacity,\n   indicating pixel coverage.  Use linear alpha blending and gamma\n   correction to correctly render non-monochrome glyph bitmaps onto a\n   surface; see @FT_Render_Glyph.\n\n   The @FT_RENDER_MODE_SDF is a special render mode that uses up to 256\n   distance values, indicating the signed distance from the grid position\n   to the nearest outline.\n\n @values:\n   FT_RENDER_MODE_NORMAL ::\n     Default render mode; it corresponds to 8-bit anti-aliased bitmaps.\n\n   FT_RENDER_MODE_LIGHT ::\n     This is equivalent to @FT_RENDER_MODE_NORMAL.  It is only defined as\n     a separate value because render modes are also used indirectly to\n     define hinting algorithm selectors.  See @FT_LOAD_TARGET_XXX for\n     details.\n\n   FT_RENDER_MODE_MONO ::\n     This mode corresponds to 1-bit bitmaps (with 2~levels of opacity).\n\n   FT_RENDER_MODE_LCD ::\n     This mode corresponds to horizontal RGB and BGR subpixel displays\n     like LCD screens.  It produces 8-bit bitmaps that are 3~times the\n     width of the original glyph outline in pixels, and which use the\n     @FT_PIXEL_MODE_LCD mode.\n\n   FT_RENDER_MODE_LCD_V ::\n     This mode corresponds to vertical RGB and BGR subpixel displays\n     (like PDA screens, rotated LCD displays, etc.).  It produces 8-bit\n     bitmaps that are 3~times the height of the original glyph outline in\n     pixels and use the @FT_PIXEL_MODE_LCD_V mode.\n\n   FT_RENDER_MODE_SDF ::\n     The positive (unsigned) 8-bit bitmap values can be converted to the\n     single-channel signed distance field (SDF) by subtracting 128, with\n     the positive and negative results corresponding to the inside and\n     the outside of a glyph contour, respectively.  The distance units are\n     arbitrarily determined by an adjustable @spread property.\n\n @note:\n   The selected render mode only affects scalable vector glyphs of a font.\n   Embedded bitmaps often have a different pixel mode like\n   @FT_PIXEL_MODE_MONO.  You can use @FT_Bitmap_Convert to transform them\n   into 8-bit pixmaps.\n"]
pub use self::FT_Render_Mode_ as FT_Render_Mode;
unsafe extern "C" {
    #[doc = " @function:\n   FT_Render_Glyph\n\n @description:\n   Convert a given glyph image to a bitmap.  It does so by inspecting the\n   glyph image format, finding the relevant renderer, and invoking it.\n\n @inout:\n   slot ::\n     A handle to the glyph slot containing the image to convert.\n\n @input:\n   render_mode ::\n     The render mode used to render the glyph image into a bitmap.  See\n     @FT_Render_Mode for a list of possible values.\n\n     If @FT_RENDER_MODE_NORMAL is used, a previous call of @FT_Load_Glyph\n     with flag @FT_LOAD_COLOR makes `FT_Render_Glyph` provide a default\n     blending of colored glyph layers associated with the current glyph\n     slot (provided the font contains such layers) instead of rendering\n     the glyph slot's outline.  This is an experimental feature; see\n     @FT_LOAD_COLOR for more information.\n\n @return:\n   FreeType error code.  0~means success.\n\n @note:\n   When FreeType outputs a bitmap of a glyph, it really outputs an alpha\n   coverage map.  If a pixel is completely covered by a filled-in\n   outline, the bitmap contains 0xFF at that pixel, meaning that\n   0xFF/0xFF fraction of that pixel is covered, meaning the pixel is 100%\n   black (or 0% bright).  If a pixel is only 50% covered (value 0x80),\n   the pixel is made 50% black (50% bright or a middle shade of grey).\n   0% covered means 0% black (100% bright or white).\n\n   On high-DPI screens like on smartphones and tablets, the pixels are so\n   small that their chance of being completely covered and therefore\n   completely black are fairly good.  On the low-DPI screens, however,\n   the situation is different.  The pixels are too large for most of the\n   details of a glyph and shades of gray are the norm rather than the\n   exception.\n\n   This is relevant because all our screens have a second problem: they\n   are not linear.  1~+~1 is not~2.  Twice the value does not result in\n   twice the brightness.  When a pixel is only 50% covered, the coverage\n   map says 50% black, and this translates to a pixel value of 128 when\n   you use 8~bits per channel (0-255).  However, this does not translate\n   to 50% brightness for that pixel on our sRGB and gamma~2.2 screens.\n   Due to their non-linearity, they dwell longer in the darks and only a\n   pixel value of about 186 results in 50% brightness -- 128 ends up too\n   dark on both bright and dark backgrounds.  The net result is that dark\n   text looks burnt-out, pixely and blotchy on bright background, bright\n   text too frail on dark backgrounds, and colored text on colored\n   background (for example, red on green) seems to have dark halos or\n   'dirt' around it.  The situation is especially ugly for diagonal stems\n   like in 'w' glyph shapes where the quality of FreeType's anti-aliasing\n   depends on the correct display of grays.  On high-DPI screens where\n   smaller, fully black pixels reign supreme, this doesn't matter, but on\n   our low-DPI screens with all the gray shades, it does.  0% and 100%\n   brightness are the same things in linear and non-linear space, just\n   all the shades in-between aren't.\n\n   The blending function for placing text over a background is\n\n   ```\n     dst = alpha * src + (1 - alpha) * dst    ,\n   ```\n\n   which is known as the OVER operator.\n\n   To correctly composite an anti-aliased pixel of a glyph onto a\n   surface,\n\n   1. take the foreground and background colors (e.g., in sRGB space)\n      and apply gamma to get them in a linear space,\n\n   2. use OVER to blend the two linear colors using the glyph pixel\n      as the alpha value (remember, the glyph bitmap is an alpha coverage\n      bitmap), and\n\n   3. apply inverse gamma to the blended pixel and write it back to\n      the image.\n\n   Internal testing at Adobe found that a target inverse gamma of~1.8 for\n   step~3 gives good results across a wide range of displays with an sRGB\n   gamma curve or a similar one.\n\n   This process can cost performance.  There is an approximation that\n   does not need to know about the background color; see\n   https://web.archive.org/web/20211019204945/https://bel.fi/alankila/lcd/\n   and\n   https://web.archive.org/web/20210211002939/https://bel.fi/alankila/lcd/alpcor.html\n   for details.\n\n   **ATTENTION**: Linear blending is even more important when dealing\n   with subpixel-rendered glyphs to prevent color-fringing!  A\n   subpixel-rendered glyph must first be filtered with a filter that\n   gives equal weight to the three color primaries and does not exceed a\n   sum of 0x100, see section @lcd_rendering.  Then the only difference to\n   gray linear blending is that subpixel-rendered linear blending is done\n   3~times per pixel: red foreground subpixel to red background subpixel\n   and so on for green and blue."]
    pub fn FT_Render_Glyph(slot: FT_GlyphSlot, render_mode: FT_Render_Mode) -> FT_Error;
}
pub const FT_Kerning_Mode__FT_KERNING_DEFAULT: FT_Kerning_Mode_ = 0;
pub const FT_Kerning_Mode__FT_KERNING_UNFITTED: FT_Kerning_Mode_ = 1;
pub const FT_Kerning_Mode__FT_KERNING_UNSCALED: FT_Kerning_Mode_ = 2;
#[doc = " @enum:\n   FT_Kerning_Mode\n\n @description:\n   An enumeration to specify the format of kerning values returned by\n   @FT_Get_Kerning.\n\n @values:\n   FT_KERNING_DEFAULT ::\n     Return grid-fitted kerning distances in 26.6 fractional pixels.\n\n   FT_KERNING_UNFITTED ::\n     Return un-grid-fitted kerning distances in 26.6 fractional pixels.\n\n   FT_KERNING_UNSCALED ::\n     Return the kerning vector in original font units.\n\n @note:\n   `FT_KERNING_DEFAULT` returns full pixel values; it also makes FreeType\n   heuristically scale down kerning distances at small ppem values so\n   that they don't become too big.\n\n   Both `FT_KERNING_DEFAULT` and `FT_KERNING_UNFITTED` use the current\n   horizontal scaling factor (as set e.g. with @FT_Set_Char_Size) to\n   convert font units to pixels."]
pub type FT_Kerning_Mode_ = ::std::os::raw::c_uint;
#[doc = " @enum:\n   FT_Kerning_Mode\n\n @description:\n   An enumeration to specify the format of kerning values returned by\n   @FT_Get_Kerning.\n\n @values:\n   FT_KERNING_DEFAULT ::\n     Return grid-fitted kerning distances in 26.6 fractional pixels.\n\n   FT_KERNING_UNFITTED ::\n     Return un-grid-fitted kerning distances in 26.6 fractional pixels.\n\n   FT_KERNING_UNSCALED ::\n     Return the kerning vector in original font units.\n\n @note:\n   `FT_KERNING_DEFAULT` returns full pixel values; it also makes FreeType\n   heuristically scale down kerning distances at small ppem values so\n   that they don't become too big.\n\n   Both `FT_KERNING_DEFAULT` and `FT_KERNING_UNFITTED` use the current\n   horizontal scaling factor (as set e.g. with @FT_Set_Char_Size) to\n   convert font units to pixels."]
pub use self::FT_Kerning_Mode_ as FT_Kerning_Mode;
unsafe extern "C" {
    #[doc = " @function:\n   FT_Get_Kerning\n\n @description:\n   Return the kerning vector between two glyphs of the same face.\n\n @input:\n   face ::\n     A handle to a source face object.\n\n   left_glyph ::\n     The index of the left glyph in the kern pair.\n\n   right_glyph ::\n     The index of the right glyph in the kern pair.\n\n   kern_mode ::\n     See @FT_Kerning_Mode for more information.  Determines the scale and\n     dimension of the returned kerning vector.\n\n @output:\n   akerning ::\n     The kerning vector.  This is either in font units, fractional pixels\n     (26.6 format), or pixels for scalable formats, and in pixels for\n     fixed-sizes formats.\n\n @return:\n   FreeType error code.  0~means success.\n\n @note:\n   Only horizontal layouts (left-to-right & right-to-left) are supported\n   by this method.  Other layouts, or more sophisticated kernings, are\n   out of the scope of this API function -- they can be implemented\n   through format-specific interfaces.\n\n   Note that, for TrueType and OpenType fonts only, this can extract data\n   from both the 'kern' table and the basic, pair-wise kerning feature\n   from the GPOS table (with `TT_CONFIG_OPTION_GPOS_KERNING` enabled),\n   though FreeType does not support the more advanced GPOS layout\n   features; use a library like HarfBuzz for those instead.  If a font\n   has both a 'kern' table and kern features of a GPOS table, the 'kern'\n   table will be used.\n\n   Also note for right-to-left scripts, the functionality may differ for\n   fonts with GPOS tables vs. 'kern' tables.  For GPOS, right-to-left\n   fonts typically use both a placement offset and an advance for pair\n   positioning, which this API does not support, so it would output\n   kerning values of zero; though if the right-to-left font used only\n   advances in GPOS pair positioning, then this API could output kerning\n   values for it, but it would use `left_glyph` to mean the first glyph\n   for that case.  Whereas 'kern' tables are always advance-only and\n   always store the left glyph first.\n\n   Use @FT_HAS_KERNING to find out whether a font has data that can be\n   extracted with `FT_Get_Kerning`."]
    pub fn FT_Get_Kerning(
        face: FT_Face,
        left_glyph: FT_UInt,
        right_glyph: FT_UInt,
        kern_mode: FT_UInt,
        akerning: *mut FT_Vector,
    ) -> FT_Error;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Get_Track_Kerning\n\n @description:\n   Return the track kerning for a given face object at a given size.\n\n @input:\n   face ::\n     A handle to a source face object.\n\n   point_size ::\n     The point size in 16.16 fractional points.\n\n   degree ::\n     The degree of tightness.  Increasingly negative values represent\n     tighter track kerning, while increasingly positive values represent\n     looser track kerning.  Value zero means no track kerning.\n\n @output:\n   akerning ::\n     The kerning in 16.16 fractional points, to be uniformly applied\n     between all glyphs.\n\n @return:\n   FreeType error code.  0~means success.\n\n @note:\n   Currently, only the Type~1 font driver supports track kerning, using\n   data from AFM files (if attached with @FT_Attach_File or\n   @FT_Attach_Stream).\n\n   Only very few AFM files come with track kerning data; please refer to\n   Adobe's AFM specification for more details."]
    pub fn FT_Get_Track_Kerning(
        face: FT_Face,
        point_size: FT_Fixed,
        degree: FT_Int,
        akerning: *mut FT_Fixed,
    ) -> FT_Error;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Select_Charmap\n\n @description:\n   Select a given charmap by its encoding tag (as listed in\n   `freetype.h`).\n\n @inout:\n   face ::\n     A handle to the source face object.\n\n @input:\n   encoding ::\n     A handle to the selected encoding.\n\n @return:\n   FreeType error code.  0~means success.\n\n @note:\n   This function returns an error if no charmap in the face corresponds\n   to the encoding queried here.\n\n   Because many fonts contain more than a single cmap for Unicode\n   encoding, this function has some special code to select the one that\n   covers Unicode best ('best' in the sense that a UCS-4 cmap is\n   preferred to a UCS-2 cmap).  It is thus preferable to @FT_Set_Charmap\n   in this case."]
    pub fn FT_Select_Charmap(face: FT_Face, encoding: FT_Encoding) -> FT_Error;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Set_Charmap\n\n @description:\n   Select a given charmap for character code to glyph index mapping.\n\n @inout:\n   face ::\n     A handle to the source face object.\n\n @input:\n   charmap ::\n     A handle to the selected charmap.\n\n @return:\n   FreeType error code.  0~means success.\n\n @note:\n   This function returns an error if the charmap is not part of the face\n   (i.e., if it is not listed in the `face->charmaps` table).\n\n   It also fails if an OpenType type~14 charmap is selected (which\n   doesn't map character codes to glyph indices at all)."]
    pub fn FT_Set_Charmap(face: FT_Face, charmap: FT_CharMap) -> FT_Error;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Get_Charmap_Index\n\n @description:\n   Retrieve index of a given charmap.\n\n @input:\n   charmap ::\n     A handle to a charmap.\n\n @return:\n   The index into the array of character maps within the face to which\n   `charmap` belongs.  If an error occurs, -1 is returned.\n"]
    pub fn FT_Get_Charmap_Index(charmap: FT_CharMap) -> FT_Int;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Get_Char_Index\n\n @description:\n   Return the glyph index of a given character code.  This function uses\n   the currently selected charmap to do the mapping.\n\n @input:\n   face ::\n     A handle to the source face object.\n\n   charcode ::\n     The character code.\n\n @return:\n   The glyph index.  0~means 'undefined character code'.\n\n @note:\n   If you use FreeType to manipulate the contents of font files directly,\n   be aware that the glyph index returned by this function doesn't always\n   correspond to the internal indices used within the file.  This is done\n   to ensure that value~0 always corresponds to the 'missing glyph'.  If\n   the first glyph is not named '.notdef', then for Type~1 and Type~42\n   fonts, '.notdef' will be moved into the glyph ID~0 position, and\n   whatever was there will be moved to the position '.notdef' had.  For\n   Type~1 fonts, if there is no '.notdef' glyph at all, then one will be\n   created at index~0 and whatever was there will be moved to the last\n   index -- Type~42 fonts are considered invalid under this condition."]
    pub fn FT_Get_Char_Index(face: FT_Face, charcode: FT_ULong) -> FT_UInt;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Get_First_Char\n\n @description:\n   Return the first character code in the current charmap of a given\n   face, together with its corresponding glyph index.\n\n @input:\n   face ::\n     A handle to the source face object.\n\n @output:\n   agindex ::\n     Glyph index of first character code.  0~if charmap is empty.\n\n @return:\n   The charmap's first character code.\n\n @note:\n   You should use this function together with @FT_Get_Next_Char to parse\n   all character codes available in a given charmap.  The code should\n   look like this:\n\n   ```\n     FT_ULong  charcode;\n     FT_UInt   gindex;\n\n\n     charcode = FT_Get_First_Char( face, &gindex );\n     while ( gindex != 0 )\n     {\n       ... do something with (charcode,gindex) pair ...\n\n       charcode = FT_Get_Next_Char( face, charcode, &gindex );\n     }\n   ```\n\n   Be aware that character codes can have values up to 0xFFFFFFFF; this\n   might happen for non-Unicode or malformed cmaps.  However, even with\n   regular Unicode encoding, so-called 'last resort fonts' (using SFNT\n   cmap format 13, see function @FT_Get_CMap_Format) normally have\n   entries for all Unicode characters up to 0x1FFFFF, which can cause *a\n   lot* of iterations.\n\n   Note that `*agindex` is set to~0 if the charmap is empty.  The result\n   itself can be~0 in two cases: if the charmap is empty or if the\n   value~0 is the first valid character code."]
    pub fn FT_Get_First_Char(face: FT_Face, agindex: *mut FT_UInt) -> FT_ULong;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Get_Next_Char\n\n @description:\n   Return the next character code in the current charmap of a given face\n   following the value `char_code`, as well as the corresponding glyph\n   index.\n\n @input:\n   face ::\n     A handle to the source face object.\n\n   char_code ::\n     The starting character code.\n\n @output:\n   agindex ::\n     Glyph index of next character code.  0~if charmap is empty.\n\n @return:\n   The charmap's next character code.\n\n @note:\n   You should use this function with @FT_Get_First_Char to walk over all\n   character codes available in a given charmap.  See the note for that\n   function for a simple code example.\n\n   Note that `*agindex` is set to~0 when there are no more codes in the\n   charmap."]
    pub fn FT_Get_Next_Char(face: FT_Face, char_code: FT_ULong, agindex: *mut FT_UInt) -> FT_ULong;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Face_Properties\n\n @description:\n   Set or override certain (library or module-wide) properties on a\n   face-by-face basis.  Useful for finer-grained control and avoiding\n   locks on shared structures (threads can modify their own faces as they\n   see fit).\n\n   Contrary to @FT_Property_Set, this function uses @FT_Parameter so that\n   you can pass multiple properties to the target face in one call.  Note\n   that only a subset of the available properties can be controlled.\n\n   * @FT_PARAM_TAG_STEM_DARKENING (stem darkening, corresponding to the\n     property `no-stem-darkening` provided by the 'autofit', 'cff',\n     'type1', and 't1cid' modules; see @no-stem-darkening).\n\n   * @FT_PARAM_TAG_LCD_FILTER_WEIGHTS (LCD filter weights, corresponding\n     to function @FT_Library_SetLcdFilterWeights).\n\n   * @FT_PARAM_TAG_RANDOM_SEED (seed value for the CFF, Type~1, and CID\n     'random' operator, corresponding to the `random-seed` property\n     provided by the 'cff', 'type1', and 't1cid' modules; see\n     @random-seed).\n\n   Pass `NULL` as `data` in @FT_Parameter for a given tag to reset the\n   option and use the library or module default again.\n\n @input:\n   face ::\n     A handle to the source face object.\n\n   num_properties ::\n     The number of properties that follow.\n\n   properties ::\n     A handle to an @FT_Parameter array with `num_properties` elements.\n\n @return:\n   FreeType error code.  0~means success.\n\n @example:\n   Here is an example that sets three properties.  You must define\n   `FT_CONFIG_OPTION_SUBPIXEL_RENDERING` to make the LCD filter examples\n   work.\n\n   ```\n     FT_Parameter         property1;\n     FT_Bool              darken_stems = 1;\n\n     FT_Parameter         property2;\n     FT_LcdFiveTapFilter  custom_weight =\n                            { 0x11, 0x44, 0x56, 0x44, 0x11 };\n\n     FT_Parameter         property3;\n     FT_Int32             random_seed = 314159265;\n\n     FT_Parameter         properties[3] = { property1,\n                                            property2,\n                                            property3 };\n\n\n     property1.tag  = FT_PARAM_TAG_STEM_DARKENING;\n     property1.data = &darken_stems;\n\n     property2.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;\n     property2.data = custom_weight;\n\n     property3.tag  = FT_PARAM_TAG_RANDOM_SEED;\n     property3.data = &random_seed;\n\n     FT_Face_Properties( face, 3, properties );\n   ```\n\n   The next example resets a single property to its default value.\n\n   ```\n     FT_Parameter  property;\n\n\n     property.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;\n     property.data = NULL;\n\n     FT_Face_Properties( face, 1, &property );\n   ```\n\n @since:\n   2.8\n"]
    pub fn FT_Face_Properties(
        face: FT_Face,
        num_properties: FT_UInt,
        properties: *mut FT_Parameter,
    ) -> FT_Error;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Get_Name_Index\n\n @description:\n   Return the glyph index of a given glyph name.  This only works\n   for those faces where @FT_HAS_GLYPH_NAMES returns true.\n\n @input:\n   face ::\n     A handle to the source face object.\n\n   glyph_name ::\n     The glyph name.\n\n @return:\n   The glyph index.  0~means 'undefined character code'.\n\n @note:\n   Acceptable glyph names might come from the [Adobe Glyph\n   List](https://github.com/adobe-type-tools/agl-aglfn).  See\n   @FT_Get_Glyph_Name for the inverse functionality.\n\n   This function has limited capabilities if the config macro\n   `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:\n   It then works only for fonts that actually embed glyph names (which\n   many recent OpenType fonts do not)."]
    pub fn FT_Get_Name_Index(face: FT_Face, glyph_name: *const FT_String) -> FT_UInt;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Get_Glyph_Name\n\n @description:\n   Retrieve the ASCII name of a given glyph in a face.  This only works\n   for those faces where @FT_HAS_GLYPH_NAMES returns true.\n\n @input:\n   face ::\n     A handle to a source face object.\n\n   glyph_index ::\n     The glyph index.\n\n   buffer_max ::\n     The maximum number of bytes available in the buffer.\n\n @output:\n   buffer ::\n     A pointer to a target buffer where the name is copied to.\n\n @return:\n   FreeType error code.  0~means success.\n\n @note:\n   An error is returned if the face doesn't provide glyph names or if the\n   glyph index is invalid.  In all cases of failure, the first byte of\n   `buffer` is set to~0 to indicate an empty name.\n\n   The glyph name is truncated to fit within the buffer if it is too\n   long.  The returned string is always zero-terminated.\n\n   Be aware that FreeType reorders glyph indices internally so that glyph\n   index~0 always corresponds to the 'missing glyph' (called '.notdef').\n\n   This function has limited capabilities if the config macro\n   `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:\n   It then works only for fonts that actually embed glyph names (which\n   many recent OpenType fonts do not)."]
    pub fn FT_Get_Glyph_Name(
        face: FT_Face,
        glyph_index: FT_UInt,
        buffer: FT_Pointer,
        buffer_max: FT_UInt,
    ) -> FT_Error;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Get_Postscript_Name\n\n @description:\n   Retrieve the ASCII PostScript name of a given face, if available.\n   This only works with PostScript, TrueType, and OpenType fonts.\n\n @input:\n   face ::\n     A handle to the source face object.\n\n @return:\n   A pointer to the face's PostScript name.  `NULL` if unavailable.\n\n @note:\n   The returned pointer is owned by the face and is destroyed with it.\n\n   For variation fonts, this string changes if you select a different\n   instance, and you have to call `FT_Get_PostScript_Name` again to\n   retrieve it.  FreeType follows Adobe TechNote #5902, 'Generating\n   PostScript Names for Fonts Using OpenType Font Variations'.\n\n     https://download.macromedia.com/pub/developer/opentype/tech-notes/5902.AdobePSNameGeneration.html\n\n   [Since 2.9] Special PostScript names for named instances are only\n   returned if the named instance is set with @FT_Set_Named_Instance (and\n   the font has corresponding entries in its 'fvar' table or is the\n   default named instance).  If @FT_IS_VARIATION returns true, the\n   algorithmically derived PostScript name is provided, not looking up\n   special entries for named instances."]
    pub fn FT_Get_Postscript_Name(face: FT_Face) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Get_SubGlyph_Info\n\n @description:\n   Retrieve a description of a given subglyph.  Only use it if\n   `glyph->format` is @FT_GLYPH_FORMAT_COMPOSITE; an error is returned\n   otherwise.\n\n @input:\n   glyph ::\n     The source glyph slot.\n\n   sub_index ::\n     The index of the subglyph.  Must be less than\n     `glyph->num_subglyphs`.\n\n @output:\n   p_index ::\n     The glyph index of the subglyph.\n\n   p_flags ::\n     The subglyph flags, see @FT_SUBGLYPH_FLAG_XXX.\n\n   p_arg1 ::\n     The subglyph's first argument (if any).\n\n   p_arg2 ::\n     The subglyph's second argument (if any).\n\n   p_transform ::\n     The subglyph transformation (if any).\n\n @return:\n   FreeType error code.  0~means success.\n\n @note:\n   The values of `*p_arg1`, `*p_arg2`, and `*p_transform` must be\n   interpreted depending on the flags returned in `*p_flags`.  See the\n   OpenType specification for details.\n\n     https://learn.microsoft.com/typography/opentype/spec/glyf#composite-glyph-description\n"]
    pub fn FT_Get_SubGlyph_Info(
        glyph: FT_GlyphSlot,
        sub_index: FT_UInt,
        p_index: *mut FT_Int,
        p_flags: *mut FT_UInt,
        p_arg1: *mut FT_Int,
        p_arg2: *mut FT_Int,
        p_transform: *mut FT_Matrix,
    ) -> FT_Error;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Get_FSType_Flags\n\n @description:\n   Return the `fsType` flags for a font.\n\n @input:\n   face ::\n     A handle to the source face object.\n\n @return:\n   The `fsType` flags, see @FT_FSTYPE_XXX.\n\n @note:\n   Use this function rather than directly reading the `fs_type` field in\n   the @PS_FontInfoRec structure, which is only guaranteed to return the\n   correct results for Type~1 fonts.\n\n @since:\n   2.3.8\n"]
    pub fn FT_Get_FSType_Flags(face: FT_Face) -> FT_UShort;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Face_GetCharVariantIndex\n\n @description:\n   Return the glyph index of a given character code as modified by the\n   variation selector.\n\n @input:\n   face ::\n     A handle to the source face object.\n\n   charcode ::\n     The character code point in Unicode.\n\n   variantSelector ::\n     The Unicode code point of the variation selector.\n\n @return:\n   The glyph index.  0~means either 'undefined character code', or\n   'undefined selector code', or 'no variation selector cmap subtable',\n   or 'current CharMap is not Unicode'.\n\n @note:\n   If you use FreeType to manipulate the contents of font files directly,\n   be aware that the glyph index returned by this function doesn't always\n   correspond to the internal indices used within the file.  This is done\n   to ensure that value~0 always corresponds to the 'missing glyph'.\n\n   This function is only meaningful if\n     a) the font has a variation selector cmap sub table, and\n     b) the current charmap has a Unicode encoding.\n\n @since:\n   2.3.6\n"]
    pub fn FT_Face_GetCharVariantIndex(
        face: FT_Face,
        charcode: FT_ULong,
        variantSelector: FT_ULong,
    ) -> FT_UInt;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Face_GetCharVariantIsDefault\n\n @description:\n   Check whether this variation of this Unicode character is the one to\n   be found in the charmap.\n\n @input:\n   face ::\n     A handle to the source face object.\n\n   charcode ::\n     The character codepoint in Unicode.\n\n   variantSelector ::\n     The Unicode codepoint of the variation selector.\n\n @return:\n   1~if found in the standard (Unicode) cmap, 0~if found in the variation\n   selector cmap, or -1 if it is not a variation.\n\n @note:\n   This function is only meaningful if the font has a variation selector\n   cmap subtable.\n\n @since:\n   2.3.6\n"]
    pub fn FT_Face_GetCharVariantIsDefault(
        face: FT_Face,
        charcode: FT_ULong,
        variantSelector: FT_ULong,
    ) -> FT_Int;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Face_GetVariantSelectors\n\n @description:\n   Return a zero-terminated list of Unicode variation selectors found in\n   the font.\n\n @input:\n   face ::\n     A handle to the source face object.\n\n @return:\n   A pointer to an array of selector code points, or `NULL` if there is\n   no valid variation selector cmap subtable.\n\n @note:\n   The last item in the array is~0; the array is owned by the @FT_Face\n   object but can be overwritten or released on the next call to a\n   FreeType function.\n\n @since:\n   2.3.6\n"]
    pub fn FT_Face_GetVariantSelectors(face: FT_Face) -> *mut FT_UInt32;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Face_GetVariantsOfChar\n\n @description:\n   Return a zero-terminated list of Unicode variation selectors found for\n   the specified character code.\n\n @input:\n   face ::\n     A handle to the source face object.\n\n   charcode ::\n     The character codepoint in Unicode.\n\n @return:\n   A pointer to an array of variation selector code points that are\n   active for the given character, or `NULL` if the corresponding list is\n   empty.\n\n @note:\n   The last item in the array is~0; the array is owned by the @FT_Face\n   object but can be overwritten or released on the next call to a\n   FreeType function.\n\n @since:\n   2.3.6\n"]
    pub fn FT_Face_GetVariantsOfChar(face: FT_Face, charcode: FT_ULong) -> *mut FT_UInt32;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Face_GetCharsOfVariant\n\n @description:\n   Return a zero-terminated list of Unicode character codes found for the\n   specified variation selector.\n\n @input:\n   face ::\n     A handle to the source face object.\n\n   variantSelector ::\n     The variation selector code point in Unicode.\n\n @return:\n   A list of all the code points that are specified by this selector\n   (both default and non-default codes are returned) or `NULL` if there\n   is no valid cmap or the variation selector is invalid.\n\n @note:\n   The last item in the array is~0; the array is owned by the @FT_Face\n   object but can be overwritten or released on the next call to a\n   FreeType function.\n\n @since:\n   2.3.6\n"]
    pub fn FT_Face_GetCharsOfVariant(face: FT_Face, variantSelector: FT_ULong) -> *mut FT_UInt32;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_MulDiv\n\n @description:\n   Compute `(a*b)/c` with maximum accuracy, using a 64-bit intermediate\n   integer whenever necessary.\n\n   This function isn't necessarily as fast as some processor-specific\n   operations, but is at least completely portable.\n\n @input:\n   a ::\n     The first multiplier.\n\n   b ::\n     The second multiplier.\n\n   c ::\n     The divisor.\n\n @return:\n   The result of `(a*b)/c`.  This function never traps when trying to\n   divide by zero; it simply returns 'MaxInt' or 'MinInt' depending on\n   the signs of `a` and `b`."]
    pub fn FT_MulDiv(a: FT_Long, b: FT_Long, c: FT_Long) -> FT_Long;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_MulFix\n\n @description:\n   Compute `(a*b)/0x10000` with maximum accuracy.  Its main use is to\n   multiply a given value by a 16.16 fixed-point factor.\n\n @input:\n   a ::\n     The first multiplier.\n\n   b ::\n     The second multiplier.  Use a 16.16 factor here whenever possible\n     (see note below).\n\n @return:\n   The result of `(a*b)/0x10000`.\n\n @note:\n   This function has been optimized for the case where the absolute value\n   of `a` is less than 2048, and `b` is a 16.16 scaling factor.  As this\n   happens mainly when scaling from notional units to fractional pixels\n   in FreeType, it resulted in noticeable speed improvements between\n   versions 2.x and 1.x.\n\n   As a conclusion, always try to place a 16.16 factor as the _second_\n   argument of this function; this can make a great difference."]
    pub fn FT_MulFix(a: FT_Long, b: FT_Long) -> FT_Long;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_DivFix\n\n @description:\n   Compute `(a*0x10000)/b` with maximum accuracy.  Its main use is to\n   divide a given value by a 16.16 fixed-point factor.\n\n @input:\n   a ::\n     The numerator.\n\n   b ::\n     The denominator.  Use a 16.16 factor here.\n\n @return:\n   The result of `(a*0x10000)/b`."]
    pub fn FT_DivFix(a: FT_Long, b: FT_Long) -> FT_Long;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_RoundFix\n\n @description:\n   Round a 16.16 fixed number.\n\n @input:\n   a ::\n     The number to be rounded.\n\n @return:\n   `a` rounded to the nearest 16.16 fixed integer, halfway cases away\n   from zero.\n\n @note:\n   The function uses wrap-around arithmetic."]
    pub fn FT_RoundFix(a: FT_Fixed) -> FT_Fixed;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_CeilFix\n\n @description:\n   Compute the smallest following integer of a 16.16 fixed number.\n\n @input:\n   a ::\n     The number for which the ceiling function is to be computed.\n\n @return:\n   `a` rounded towards plus infinity.\n\n @note:\n   The function uses wrap-around arithmetic."]
    pub fn FT_CeilFix(a: FT_Fixed) -> FT_Fixed;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_FloorFix\n\n @description:\n   Compute the largest previous integer of a 16.16 fixed number.\n\n @input:\n   a ::\n     The number for which the floor function is to be computed.\n\n @return:\n   `a` rounded towards minus infinity."]
    pub fn FT_FloorFix(a: FT_Fixed) -> FT_Fixed;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Vector_Transform\n\n @description:\n   Transform a single vector through a 2x2 matrix.\n\n @inout:\n   vector ::\n     The target vector to transform.\n\n @input:\n   matrix ::\n     A pointer to the source 2x2 matrix.\n\n @note:\n   The result is undefined if either `vector` or `matrix` is invalid."]
    pub fn FT_Vector_Transform(vector: *mut FT_Vector, matrix: *const FT_Matrix);
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Library_Version\n\n @description:\n   Return the version of the FreeType library being used.  This is useful\n   when dynamically linking to the library, since one cannot use the\n   macros @FREETYPE_MAJOR, @FREETYPE_MINOR, and @FREETYPE_PATCH.\n\n @input:\n   library ::\n     A source library handle.\n\n @output:\n   amajor ::\n     The major version number.\n\n   aminor ::\n     The minor version number.\n\n   apatch ::\n     The patch version number.\n\n @note:\n   The reason why this function takes a `library` argument is because\n   certain programs implement library initialization in a custom way that\n   doesn't use @FT_Init_FreeType.\n\n   In such cases, the library version might not be available before the\n   library object has been created."]
    pub fn FT_Library_Version(
        library: FT_Library,
        amajor: *mut FT_Int,
        aminor: *mut FT_Int,
        apatch: *mut FT_Int,
    );
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Face_CheckTrueTypePatents\n\n @description:\n   Deprecated, does nothing.\n\n @input:\n   face ::\n     A face handle.\n\n @return:\n   Always returns false.\n\n @note:\n   Since May 2010, TrueType hinting is no longer patented.\n\n @since:\n   2.3.5\n"]
    pub fn FT_Face_CheckTrueTypePatents(face: FT_Face) -> FT_Bool;
}
unsafe extern "C" {
    #[doc = " @function:\n   FT_Face_SetUnpatentedHinting\n\n @description:\n   Deprecated, does nothing.\n\n @input:\n   face ::\n     A face handle.\n\n   value ::\n     New boolean setting.\n\n @return:\n   Always returns false.\n\n @note:\n   Since May 2010, TrueType hinting is no longer patented.\n\n @since:\n   2.3.5\n"]
    pub fn FT_Face_SetUnpatentedHinting(face: FT_Face, value: FT_Bool) -> FT_Bool;
}
pub const FT_LcdFilter__FT_LCD_FILTER_NONE: FT_LcdFilter_ = 0;
pub const FT_LcdFilter__FT_LCD_FILTER_DEFAULT: FT_LcdFilter_ = 1;
pub const FT_LcdFilter__FT_LCD_FILTER_LIGHT: FT_LcdFilter_ = 2;
pub const FT_LcdFilter__FT_LCD_FILTER_LEGACY1: FT_LcdFilter_ = 3;
pub const FT_LcdFilter__FT_LCD_FILTER_LEGACY: FT_LcdFilter_ = 16;
pub const FT_LcdFilter__FT_LCD_FILTER_MAX: FT_LcdFilter_ = 17;
pub type FT_LcdFilter_ = ::std::os::raw::c_uint;
pub use self::FT_LcdFilter_ as FT_LcdFilter;
unsafe extern "C" {
    pub fn FT_Library_SetLcdFilter(library: FT_Library, filter: FT_LcdFilter) -> FT_Error;
}
unsafe extern "C" {
    pub fn FT_Library_SetLcdFilterWeights(
        library: FT_Library,
        weights: *mut ::std::os::raw::c_uchar,
    ) -> FT_Error;
}
pub type FT_LcdFiveTapFilter = [FT_Byte; 5usize];
unsafe extern "C" {
    pub fn FT_Library_SetLcdGeometry(library: FT_Library, sub: *mut FT_Vector) -> FT_Error;
}
pub const FT_Sfnt_Tag__FT_SFNT_HEAD: FT_Sfnt_Tag_ = 0;
pub const FT_Sfnt_Tag__FT_SFNT_MAXP: FT_Sfnt_Tag_ = 1;
pub const FT_Sfnt_Tag__FT_SFNT_OS2: FT_Sfnt_Tag_ = 2;
pub const FT_Sfnt_Tag__FT_SFNT_HHEA: FT_Sfnt_Tag_ = 3;
pub const FT_Sfnt_Tag__FT_SFNT_VHEA: FT_Sfnt_Tag_ = 4;
pub const FT_Sfnt_Tag__FT_SFNT_POST: FT_Sfnt_Tag_ = 5;
pub const FT_Sfnt_Tag__FT_SFNT_PCLT: FT_Sfnt_Tag_ = 6;
pub const FT_Sfnt_Tag__FT_SFNT_MAX: FT_Sfnt_Tag_ = 7;
pub type FT_Sfnt_Tag_ = ::std::os::raw::c_uint;
pub use self::FT_Sfnt_Tag_ as FT_Sfnt_Tag;
unsafe extern "C" {
    pub fn FT_Get_Sfnt_Table(face: FT_Face, tag: FT_Sfnt_Tag) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn FT_Load_Sfnt_Table(
        face: FT_Face,
        tag: FT_ULong,
        offset: FT_Long,
        buffer: *mut FT_Byte,
        length: *mut FT_ULong,
    ) -> FT_Error;
}
unsafe extern "C" {
    pub fn FT_Sfnt_Table_Info(
        face: FT_Face,
        table_index: FT_UInt,
        tag: *mut FT_ULong,
        length: *mut FT_ULong,
    ) -> FT_Error;
}
unsafe extern "C" {
    pub fn FT_Get_CMap_Language_ID(charmap: FT_CharMap) -> FT_ULong;
}
unsafe extern "C" {
    pub fn FT_Get_CMap_Format(charmap: FT_CharMap) -> FT_Long;
}
pub type FT_Module_Interface = FT_Pointer;
pub type FT_Module_Constructor =
    ::std::option::Option<unsafe extern "C" fn(module: FT_Module) -> FT_Error>;
pub type FT_Module_Destructor = ::std::option::Option<unsafe extern "C" fn(module: FT_Module)>;
pub type FT_Module_Requester = ::std::option::Option<
    unsafe extern "C" fn(
        module: FT_Module,
        name: *const ::std::os::raw::c_char,
    ) -> FT_Module_Interface,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Module_Class_ {
    pub module_flags: FT_ULong,
    pub module_size: FT_Long,
    pub module_name: *const FT_String,
    pub module_version: FT_Fixed,
    pub module_requires: FT_Fixed,
    pub module_interface: *const ::std::os::raw::c_void,
    pub module_init: FT_Module_Constructor,
    pub module_done: FT_Module_Destructor,
    pub get_interface: FT_Module_Requester,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FT_Module_Class_"][::std::mem::size_of::<FT_Module_Class_>() - 72usize];
    ["Alignment of FT_Module_Class_"][::std::mem::align_of::<FT_Module_Class_>() - 8usize];
    ["Offset of field: FT_Module_Class_::module_flags"]
        [::std::mem::offset_of!(FT_Module_Class_, module_flags) - 0usize];
    ["Offset of field: FT_Module_Class_::module_size"]
        [::std::mem::offset_of!(FT_Module_Class_, module_size) - 8usize];
    ["Offset of field: FT_Module_Class_::module_name"]
        [::std::mem::offset_of!(FT_Module_Class_, module_name) - 16usize];
    ["Offset of field: FT_Module_Class_::module_version"]
        [::std::mem::offset_of!(FT_Module_Class_, module_version) - 24usize];
    ["Offset of field: FT_Module_Class_::module_requires"]
        [::std::mem::offset_of!(FT_Module_Class_, module_requires) - 32usize];
    ["Offset of field: FT_Module_Class_::module_interface"]
        [::std::mem::offset_of!(FT_Module_Class_, module_interface) - 40usize];
    ["Offset of field: FT_Module_Class_::module_init"]
        [::std::mem::offset_of!(FT_Module_Class_, module_init) - 48usize];
    ["Offset of field: FT_Module_Class_::module_done"]
        [::std::mem::offset_of!(FT_Module_Class_, module_done) - 56usize];
    ["Offset of field: FT_Module_Class_::get_interface"]
        [::std::mem::offset_of!(FT_Module_Class_, get_interface) - 64usize];
};
pub type FT_Module_Class = FT_Module_Class_;
unsafe extern "C" {
    pub fn FT_Add_Module(library: FT_Library, clazz: *const FT_Module_Class) -> FT_Error;
}
unsafe extern "C" {
    pub fn FT_Get_Module(
        library: FT_Library,
        module_name: *const ::std::os::raw::c_char,
    ) -> FT_Module;
}
unsafe extern "C" {
    pub fn FT_Remove_Module(library: FT_Library, module: FT_Module) -> FT_Error;
}
unsafe extern "C" {
    pub fn FT_Property_Set(
        library: FT_Library,
        module_name: *const FT_String,
        property_name: *const FT_String,
        value: *const ::std::os::raw::c_void,
    ) -> FT_Error;
}
unsafe extern "C" {
    pub fn FT_Property_Get(
        library: FT_Library,
        module_name: *const FT_String,
        property_name: *const FT_String,
        value: *mut ::std::os::raw::c_void,
    ) -> FT_Error;
}
unsafe extern "C" {
    pub fn FT_Set_Default_Properties(library: FT_Library);
}
unsafe extern "C" {
    pub fn FT_Reference_Library(library: FT_Library) -> FT_Error;
}
unsafe extern "C" {
    pub fn FT_New_Library(memory: FT_Memory, alibrary: *mut FT_Library) -> FT_Error;
}
unsafe extern "C" {
    pub fn FT_Done_Library(library: FT_Library) -> FT_Error;
}
pub type FT_DebugHook_Func =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> FT_Error>;
unsafe extern "C" {
    pub fn FT_Set_Debug_Hook(
        library: FT_Library,
        hook_index: FT_UInt,
        debug_hook: FT_DebugHook_Func,
    );
}
unsafe extern "C" {
    pub fn FT_Add_Default_Modules(library: FT_Library);
}
pub const FT_TrueTypeEngineType__FT_TRUETYPE_ENGINE_TYPE_NONE: FT_TrueTypeEngineType_ = 0;
pub const FT_TrueTypeEngineType__FT_TRUETYPE_ENGINE_TYPE_UNPATENTED: FT_TrueTypeEngineType_ = 1;
pub const FT_TrueTypeEngineType__FT_TRUETYPE_ENGINE_TYPE_PATENTED: FT_TrueTypeEngineType_ = 2;
pub type FT_TrueTypeEngineType_ = ::std::os::raw::c_uint;
pub use self::FT_TrueTypeEngineType_ as FT_TrueTypeEngineType;
unsafe extern "C" {
    pub fn FT_Get_TrueType_Engine_Type(library: FT_Library) -> FT_TrueTypeEngineType;
}
unsafe extern "C" {
    pub fn FT_Outline_Decompose(
        outline: *mut FT_Outline,
        func_interface: *const FT_Outline_Funcs,
        user: *mut ::std::os::raw::c_void,
    ) -> FT_Error;
}
unsafe extern "C" {
    pub fn FT_Outline_New(
        library: FT_Library,
        numPoints: FT_UInt,
        numContours: FT_Int,
        anoutline: *mut FT_Outline,
    ) -> FT_Error;
}
unsafe extern "C" {
    pub fn FT_Outline_Done(library: FT_Library, outline: *mut FT_Outline) -> FT_Error;
}
unsafe extern "C" {
    pub fn FT_Outline_Check(outline: *mut FT_Outline) -> FT_Error;
}
unsafe extern "C" {
    pub fn FT_Outline_Get_CBox(outline: *const FT_Outline, acbox: *mut FT_BBox);
}
unsafe extern "C" {
    pub fn FT_Outline_Translate(outline: *const FT_Outline, xOffset: FT_Pos, yOffset: FT_Pos);
}
unsafe extern "C" {
    pub fn FT_Outline_Copy(source: *const FT_Outline, target: *mut FT_Outline) -> FT_Error;
}
unsafe extern "C" {
    pub fn FT_Outline_Transform(outline: *const FT_Outline, matrix: *const FT_Matrix);
}
unsafe extern "C" {
    pub fn FT_Outline_Embolden(outline: *mut FT_Outline, strength: FT_Pos) -> FT_Error;
}
unsafe extern "C" {
    pub fn FT_Outline_EmboldenXY(
        outline: *mut FT_Outline,
        xstrength: FT_Pos,
        ystrength: FT_Pos,
    ) -> FT_Error;
}
unsafe extern "C" {
    pub fn FT_Outline_Reverse(outline: *mut FT_Outline);
}
unsafe extern "C" {
    pub fn FT_Outline_Get_Bitmap(
        library: FT_Library,
        outline: *mut FT_Outline,
        abitmap: *const FT_Bitmap,
    ) -> FT_Error;
}
unsafe extern "C" {
    pub fn FT_Outline_Render(
        library: FT_Library,
        outline: *mut FT_Outline,
        params: *mut FT_Raster_Params,
    ) -> FT_Error;
}
pub const FT_Orientation__FT_ORIENTATION_TRUETYPE: FT_Orientation_ = 0;
pub const FT_Orientation__FT_ORIENTATION_POSTSCRIPT: FT_Orientation_ = 1;
pub const FT_Orientation__FT_ORIENTATION_FILL_RIGHT: FT_Orientation_ = 0;
pub const FT_Orientation__FT_ORIENTATION_FILL_LEFT: FT_Orientation_ = 1;
pub const FT_Orientation__FT_ORIENTATION_NONE: FT_Orientation_ = 2;
pub type FT_Orientation_ = ::std::os::raw::c_uint;
pub use self::FT_Orientation_ as FT_Orientation;
unsafe extern "C" {
    pub fn FT_Outline_Get_Orientation(outline: *mut FT_Outline) -> FT_Orientation;
}
